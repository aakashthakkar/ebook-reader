<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SonicRead - Listen to your PDFs</title>
    <link rel="icon" href="data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 75 33.51'%3e%3cg data-name='Layer 2'%3e%3cpath fill='%236D28D9' d='M75 23.6a10.5 10.5 0 0 1-10.63 9.91H38.82a2.14 2.14 0 0 1-2.12-2.13V3.87a2.34 2.34 0 0 1 1.41-2.24S40.46 0 45.41 0A16.74 16.74 0 0 1 54 2.36a17 17 0 0 1 8 11.08 9.8 9.8 0 0 1 2.71-.37A10.23 10.23 0 0 1 75 23.6ZM33.51 5.61a.83.83 0 1 0-1.65 0c-.7 9.25-1.24 17.92 0 27.14a.83.83 0 0 0 1.65 0c1.33-9.3.77-17.81 0-27.14ZM28.35 8.81a.87.87 0 0 0-1.73 0 103.7 103.7 0 0 0 0 23.95.87.87 0 0 0 1.72 0 93.2 93.2 0 0 0 .01-23.95ZM23.16 8a.84.84 0 0 0-1.67 0c-.79 8.44-1.19 16.32 0 24.74a.83.83 0 0 0 1.66 0c1.23-8.53.85-16.19.01-24.74ZM18 10.41a.86.86 0 0 0-1.72 0 87.61 87.61 0 0 0 0 22.36.85.85 0 0 0 1.69 0A81.68 81.68 0 0 0 18 10.41ZM12.79 16a.85.85 0 0 0-1.7 0c-1.23 5.76-.65 11 .05 16.83a.81.81 0 0 0 1.6 0c.77-5.91 1.36-11.03.05-16.83ZM7.62 15.12a.88.88 0 0 0-1.75 0C4.78 21 5.14 26.18 5.9 32.05c.08.89 1.59.88 1.69 0 .84-5.96 1.23-10.99.03-16.93ZM2.4 18a.88.88 0 0 0-1.75 0c-1 3.95-.69 7.22.07 11.18a.82.82 0 0 0 1.63 0c.88-4.04 1.31-7.24.05-11.18Z'/%3e%3c/g%3e%3c/svg%3e">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js"></script>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">

    <style>
        :root {
            --background: 222.2 84% 4.9%;
            --foreground: 210 40% 98%;
            --card: 222.2 84% 4.9%;
            --card-foreground: 210 40% 98%;
            --popover: 222.2 84% 4.9%;
            --popover-foreground: 210 40% 98%;
            --primary: 217.2 91.2% 59.8%;
            --primary-foreground: 222.2 47.4% 11.2%;
            --secondary: 217.2 32.6% 17.5%;
            --secondary-foreground: 210 40% 98%;
            --muted: 217.2 32.6% 17.5%;
            --muted-foreground: 215 20.2% 65.1%;
            --accent: 217.2 32.6% 17.5%;
            --accent-foreground: 210 40% 98%;
            --destructive: 0 62.8% 30.6%;
            --destructive-foreground: 210 40% 98%;
            --border: 217.2 32.6% 17.5%;
            --input: 217.2 32.6% 17.5%;
            --ring: 224.3 76.3% 48%;
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: hsl(var(--background));
            color: hsl(var(--foreground));
        }

        .spinner { animation: spin 1s linear infinite; }
        @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
        
        #pdf-viewer { position: relative; overflow-y: auto; overflow-x: hidden; height: calc(100vh - 80px); /* Full height minus player */ }
        .pdf-page { position: relative; margin: 20px auto; background: white; box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2); }
        .pdf-page canvas { display: block; width: 100%; height: auto; }
        .text-layer { position: absolute; top: 0; left: 0; right: 0; bottom: 0; z-index: 2; }
        .text-span {
            position: absolute;
            pointer-events: auto;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            background-color: transparent;
        }
        .text-span:hover { background-color: hsla(var(--primary), 0.3) !important; }
        .text-span.word-playing-chunk { background-color: hsla(217, 91%, 60%, 0.3) !important; }
        .text-span.word-next-chunk { background-color: hsla(var(--primary), 0.15) !important; }
        .text-span.word-current {
            background-color: hsla(142, 71%, 41%, 0.6) !important;
            animation: pulse-word 1.5s infinite;
            z-index: 10 !important;
        }
        @keyframes pulse-word { 0%, 100% { transform: scale(1.0); } 50% { transform: scale(1.05); } }

        .upload-area.dragover {
            border-color: hsl(var(--primary));
            transform: scale(1.02);
            background-color: hsl(var(--secondary));
        }
    </style>
</head>
<body class="bg-slate-950 text-slate-200 selection:bg-slate-700">
    <main id="app-container" class="transition-all duration-300">
        <div id="upload-container">
            <header class="absolute top-0 left-0 right-0 z-20 bg-slate-950/50 backdrop-blur-lg border-b border-slate-800/50">
                <div class="flex items-center justify-between max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 h-16">
                     <div class="flex items-center space-x-3">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" class="text-blue-500">
                            <path d="M2.75 12C2.75 11.5858 3.08579 11.25 3.5 11.25H4.25C4.66421 11.25 5 11.5858 5 12V16C5 16.4142 4.66421 16.75 4.25 16.75H3.5C3.08579 16.75 2.75 16.4142 2.75 16V12Z" fill="currentColor" />
                            <path d="M6.75 8C6.75 7.58579 7.08579 7.25 7.5 7.25H8.25C8.66421 7.25 9 7.58579 9 8V16C9 16.4142 8.66421 16.75 8.25 16.75H7.5C7.08579 16.75 6.75 16.4142 6.75 16V8Z" fill="currentColor" />
                            <path d="M10.75 10C10.75 9.58579 11.0858 9.25 11.5 9.25H12.25C12.6642 9.25 13 9.58579 13 10V16C13 16.4142 12.6642 16.75 12.25 16.75H11.5C11.0858 16.75 10.75 16.4142 10.75 16V10Z" fill="currentColor" />
                            <path d="M14.75 6C14.75 5.58579 15.0858 5.25 15.5 5.25H16.25C16.6642 5.25 17 5.58579 17 6V16C17 16.4142 16.6642 16.75 16.25 16.75H15.5C15.0858 16.75 14.75 16.4142 14.75 16V6Z" fill="currentColor" />
                            <path d="M18.75 9C18.75 8.58579 19.0858 8.25 19.5 8.25H20.25C20.6642 8.25 21 8.58579 21 9V16C21 16.4142 20.6642 16.75 20.25 16.75H19.5C19.0858 16.75 18.75 16.4142 18.75 16V9Z" fill="currentColor" />
                        </svg>
                        <h1 class="text-xl font-bold text-slate-100">SonicRead</h1>
                    </div>
                    <div class="flex items-center space-x-4">
                        <span id="user-welcome" class="hidden sm:block text-sm text-slate-400"></span>
                        <button id="logout-btn" class="flex items-center gap-2 px-3 py-1.5 bg-slate-800/60 hover:bg-slate-700/80 text-white text-sm rounded-lg transition-colors border border-slate-700">
                            <i data-lucide="log-out" class="h-4 w-4"></i>
                            <span class="hidden sm:inline">Logout</span>
                        </button>
                    </div>
                </div>
            </header>
            <div class="min-h-screen flex flex-col items-center justify-center p-4 pt-24">
                <div class="text-center w-full max-w-4xl mx-auto">
                    <h2 class="text-4xl md:text-5xl lg:text-6xl font-extrabold mb-4">
                        <span class="text-transparent bg-clip-text bg-gradient-to-r from-blue-400 to-purple-500">Listen to your PDFs,</span>
                        <span class="text-slate-200">hands-free.</span>
                    </h2>
                    <p class="text-lg md:text-xl text-slate-400 mb-12 max-w-2xl mx-auto">Upload any document and have it read out to you with perfectly synced, real-time text highlighting.</p>

                    <!-- User's PDF Files Section -->
                    <div id="user-pdfs-section" class="mb-12">
                        <div id="user-pdfs-loading" class="text-center py-8">
                            <div class="w-6 h-6 mx-auto spinner border-2 border-blue-400 border-t-transparent rounded-full"></div>
                            <p class="text-sm text-slate-400 mt-3">Loading your PDFs...</p>
                        </div>
                        
                        <div id="user-pdfs-list" class="hidden">
                            <div class="flex items-center justify-between mb-8">
                                <h3 class="text-2xl font-bold text-slate-100">Your PDF Library</h3>
                                <span class="text-sm text-slate-400 bg-slate-800/50 px-3 py-1 rounded-full" id="pdf-count">0 documents</span>
                            </div>
                            <div id="pdfs-grid" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-6">
                                <!-- PDF items will be inserted here -->
                            </div>
                        </div>
                        
                        <div id="user-pdfs-empty" class="hidden text-center py-12">
                            <div class="bg-slate-800/30 rounded-2xl p-8 max-w-md mx-auto">
                                <i data-lucide="book-open" class="h-12 w-12 text-slate-500 mx-auto mb-4"></i>
                                <h4 class="text-lg font-semibold text-slate-200 mb-2">No PDFs yet</h4>
                                <p class="text-slate-400 text-sm">Upload your first PDF to start listening!</p>
                            </div>
                        </div>
                    </div>




                    <!-- Upload Sections Container -->
                    <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">
                        <!-- PDF Upload Card -->
                        <div class="group relative overflow-hidden bg-slate-900/50 backdrop-blur-sm border border-slate-700/50 rounded-2xl p-6 transition-all duration-300 hover:border-blue-500/50 hover:bg-slate-800/60">
                            <div class="flex items-center gap-4 mb-6">
                                <div class="w-12 h-12 bg-blue-500/10 rounded-xl flex items-center justify-center border border-blue-500/20">
                                    <i data-lucide="file-text" class="h-6 w-6 text-blue-400"></i>
                                </div>
                                <div>
                                    <h3 class="text-lg font-semibold text-slate-100">Upload PDF</h3>
                                    <p class="text-sm text-slate-400">Add documents to your library</p>
                                </div>
                            </div>
                            
                            <div id="upload-area" class="upload-area border-2 border-dashed border-slate-600/60 rounded-xl p-6 text-center cursor-pointer hover:border-blue-500/60 transition-all duration-300">
                                <div class="flex flex-col items-center space-y-3">
                                    <div class="w-14 h-14 bg-slate-800/50 rounded-2xl flex items-center justify-center group-hover:bg-blue-500/10 transition-all duration-300">
                                        <i data-lucide="upload-cloud" class="h-7 w-7 text-slate-500 group-hover:text-blue-400 transition-colors"></i>
                                    </div>
                                    <div>
                                        <h4 class="font-medium text-slate-200 mb-1">Drop your PDF here</h4>
                                        <p class="text-sm text-slate-400">or <span class="text-blue-400 font-medium hover:text-blue-300 transition-colors">click to browse</span></p>
                                    </div>
                                    <p class="text-xs text-slate-500">Supports PDF files up to 500MB</p>
                                </div>
                                <input type="file" id="pdf-input" accept=".pdf" class="hidden">
                            </div>
                        </div>

                        <!-- Background Music Upload Card -->
                        <div class="group relative overflow-hidden bg-slate-900/50 backdrop-blur-sm border border-slate-700/50 rounded-2xl p-6 transition-all duration-300 hover:border-purple-500/50 hover:bg-slate-800/60">
                            <div class="flex items-center justify-between mb-4">
                                <div class="flex items-center gap-4">
                                    <div class="w-12 h-12 bg-purple-500/10 rounded-xl flex items-center justify-center border border-purple-500/20">
                                        <i data-lucide="music" class="h-6 w-6 text-purple-400"></i>
                                    </div>
                                    <div>
                                        <h3 class="text-lg font-semibold text-slate-100">Background Music</h3>
                                        <p class="text-sm text-slate-400">Enhance your experience</p>
                                    </div>
                                </div>
                                <button id="upload-music-btn" class="inline-flex items-center gap-2 px-3 py-2 bg-purple-600 hover:bg-purple-700 text-white text-sm rounded-lg transition-all duration-200 hover:scale-105 shadow-sm shadow-black/20">
                                    <i data-lucide="upload" class="h-4 w-4"></i>
                                    Upload
                                </button>
                            </div>
                            
                            <!-- YouTube Download Instructions -->
                            <div class="mb-4 p-3 bg-blue-900/20 border border-blue-700/30 rounded-xl">
                                <div class="flex items-start gap-3">
                                    <div class="w-8 h-8 bg-blue-500/20 rounded-lg flex items-center justify-center flex-shrink-0 mt-0.5">
                                        <i data-lucide="info" class="h-4 w-4 text-blue-400"></i>
                                    </div>
                                    <div>
                                        <h4 class="text-sm font-semibold text-blue-200 mb-1">Get music from YouTube</h4>
                                        <p class="text-xs text-blue-300/80">
                                            Use a service like <a href="https://ytmp3.cc/mZ9P" target="_blank" rel="noopener noreferrer" class="text-blue-400 hover:text-blue-300 underline font-medium">ytmp3.cc</a> to download audio, then upload here.
                                        </p>
                                    </div>
                                </div>
                            </div>
                            
                            <div id="music-list-loading" class="text-center py-6">
                                <div class="w-5 h-5 mx-auto spinner border-2 border-purple-400 border-t-transparent rounded-full"></div>
                                <p class="text-sm text-slate-400 mt-3">Loading music...</p>
                            </div>
                            
                            <div id="music-list-container" class="hidden">
                                <div class="mb-3">
                                    <h4 class="text-sm font-medium text-slate-300">Uploaded Music</h4>
                                </div>
                                <div id="music-list" class="space-y-2 max-h-36 overflow-y-auto scrollbar-thin scrollbar-thumb-slate-600 scrollbar-track-slate-800/50 pr-2">
                                    <!-- Music items will be inserted here -->
                                </div>
                            </div>
                            
                            <div id="music-list-empty" class="hidden text-center py-6">
                                <div class="w-12 h-12 bg-purple-500/20 rounded-2xl flex items-center justify-center mx-auto mb-3">
                                    <i data-lucide="music" class="h-6 w-6 text-purple-400"></i>
                                </div>
                                <p class="text-sm text-slate-400">No background music yet</p>
                            </div>
                        </div>
                    </div>

                    <div id="upload-loading-text" class="hidden fixed inset-0 bg-black/50 backdrop-blur-sm z-[100] flex items-center justify-center">
                        <div class="bg-slate-800 p-8 rounded-2xl shadow-lg flex flex-col items-center gap-4">
                            <div class="w-8 h-8 spinner border-4 border-blue-400 border-t-transparent rounded-full"></div>
                            <p class="text-lg font-medium text-blue-300" id="upload-loading-text-inner">Processing PDF...</p>
                        </div>
                    </div>

                    <!-- Default Voice Settings Section -->
                    <div class="max-w-2xl mx-auto mt-16">
                        <div class="text-center mb-8">
                            <h3 class="text-2xl font-bold text-slate-100 mb-4">Default Voice Settings</h3>
                            <p class="text-slate-400">Configure your preferred voice and speed. These settings will be applied to all new PDFs by default.</p>
                        </div>
                        
                        <div class="bg-slate-900/50 backdrop-blur-sm border border-slate-700/50 rounded-2xl p-8">
                            <div class="grid grid-cols-1 sm:grid-cols-2 gap-6 mb-8">
                                <!-- Voice Selection -->
                                <div class="space-y-3">
                                    <div class="flex items-center gap-3 mb-2">
                                        <div class="w-10 h-10 bg-blue-500/10 rounded-xl flex items-center justify-center border border-blue-500/20">
                                            <i data-lucide="mic" class="h-5 w-5 text-blue-400"></i>
                                        </div>
                                        <div>
                                            <label for="default-voice-select" class="text-sm font-medium text-slate-200">Voice</label>
                                            <p class="text-xs text-slate-400">Choose your preferred narrator</p>
                                        </div>
                                    </div>
                                    <div class="relative">
                                        <select id="default-voice-select" class="w-full bg-slate-800 text-white text-sm rounded-lg px-4 py-3 pr-10 border border-slate-700 focus:border-blue-500 focus:ring-0 outline-none appearance-none">
                                            {% for key, model in models.items() %}
                                            <option value="{{ key }}" {% if key == 'edge-tts-andrew' %}selected{% endif %}>{{ model.name }}</option>
                                            {% endfor %}
                                        </select>
                                        <div class="absolute inset-y-0 right-0 flex items-center pr-3 pointer-events-none">
                                            <i data-lucide="chevron-down" class="h-4 w-4 text-slate-400"></i>
                                        </div>
                                    </div>
                                </div>
                                
                                <!-- Speed Selection -->
                                <div class="space-y-3">
                                    <div class="flex items-center gap-3 mb-2">
                                        <div class="w-10 h-10 bg-green-500/10 rounded-xl flex items-center justify-center border border-green-500/20">
                                            <i data-lucide="gauge" class="h-5 w-5 text-green-400"></i>
                                        </div>
                                        <div>
                                            <label for="default-speed-select" class="text-sm font-medium text-slate-200">Speed</label>
                                            <p class="text-xs text-slate-400">Set your reading pace</p>
                                        </div>
                                    </div>
                                    <div class="relative">
                                        <select id="default-speed-select" class="w-full bg-slate-800 text-white text-sm rounded-lg px-4 py-3 pr-10 border border-slate-700 focus:border-green-500 focus:ring-0 outline-none appearance-none">
                                            <option value="0.5">0.5x (Very Slow)</option>
                                            <option value="0.75">0.75x (Slow)</option>
                                            <option value="1.0" selected>1.0x (Normal)</option>
                                            <option value="1.25">1.25x (Fast)</option>
                                            <option value="1.5">1.5x (Faster)</option>
                                            <option value="2.0">2.0x (Very Fast)</option>
                                        </select>
                                        <div class="absolute inset-y-0 right-0 flex items-center pr-3 pointer-events-none">
                                            <i data-lucide="chevron-down" class="h-4 w-4 text-slate-400"></i>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Skip Patterns Option -->
                            <div class="mb-8 p-4 bg-slate-800/30 rounded-xl border border-slate-700/50">
                                <div class="flex items-center justify-between">
                                    <div class="flex items-center gap-3">
                                        <div class="w-10 h-10 bg-purple-500/10 rounded-xl flex items-center justify-center border border-purple-500/20">
                                            <i data-lucide="skip-forward" class="h-5 w-5 text-purple-400"></i>
                                        </div>
                                        <div>
                                            <label for="default-skip-patterns" class="text-sm font-medium text-slate-200">Skip Headers/Footers</label>
                                            <p class="text-xs text-slate-400">Automatically skip page numbers and headers</p>
                                        </div>
                                    </div>
                                    <label class="relative inline-flex items-center cursor-pointer">
                                        <input type="checkbox" id="default-skip-patterns" class="sr-only peer">
                                        <div class="w-11 h-6 bg-slate-700 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-purple-300/20 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-purple-600"></div>
                                    </label>
                                </div>
                            </div>
                            
                            <!-- Action Buttons -->
                            <div class="flex flex-col sm:flex-row gap-4">
                                <button id="test-voice-btn" class="flex-1 inline-flex items-center justify-center gap-2 px-6 py-3 bg-green-600 hover:bg-green-700 text-white font-medium rounded-lg transition-all duration-200 hover:scale-105 shadow-lg shadow-green-600/20">
                                    <i data-lucide="play-circle" class="h-5 w-5"></i>
                                    <span id="test-voice-btn-text">Test Voice & Speed</span>
                                </button>
                                <button id="save-default-prefs-btn" class="flex-1 inline-flex items-center justify-center gap-2 px-6 py-3 bg-blue-600 hover:bg-blue-700 text-white font-medium rounded-lg transition-all duration-200 hover:scale-105 shadow-lg shadow-blue-600/20">
                                    <i data-lucide="save" class="h-5 w-5"></i>
                                    Save as Default
                                </button>
                            </div>
                            
                            <!-- Test audio player -->
                            <audio id="test-audio-player" style="display:none;"></audio>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div id="pdf-display" class="hidden">
            <div class="bg-slate-900/95 backdrop-blur-sm fixed top-0 left-0 right-0 z-50 border-b border-slate-700">
                <div class="max-w-7xl mx-auto px-2 sm:px-4 lg:px-6">
                    <div class="flex items-center h-16 gap-1 sm:gap-2">
                        <!-- Left section - more compact -->
                        <div class="flex items-center space-x-1 flex-shrink-0">
                             <button id="pdf-start-reading" class="inline-flex items-center justify-center rounded-lg text-sm font-medium transition-colors bg-blue-600 text-white hover:bg-blue-700 h-8 w-8 sm:h-9 sm:w-auto sm:px-4 sm:py-2 sm:gap-2">
                                <i data-lucide="play-circle" class="h-4 w-4"></i>
                                <span class="hidden sm:inline">Start</span>
                             </button>
                             <button id="top-go-to-current" class="hidden md:inline-flex items-center justify-center rounded-lg text-sm font-medium transition-colors border border-slate-600 bg-slate-800 hover:bg-slate-700 hover:text-slate-200 text-slate-300 h-9 px-3 py-2 gap-2">
                                <i data-lucide="crosshair" class="h-4 w-4"></i>
                                <span class="hidden lg:inline">Go to Current</span>
                             </button>
                        </div>
                        
                        <!-- Center section - very compact on mobile -->
                        <div class="flex items-center space-x-1 text-slate-300 flex-1 justify-center min-w-0">
                             <button id="pdf-zoom-out" class="inline-flex items-center justify-center rounded-lg text-sm font-medium transition-colors hover:bg-slate-700 hover:text-slate-200 text-slate-300 h-8 w-8">
                                <i data-lucide="zoom-out" class="h-3 w-3"></i>
                             </button>
                             <span id="pdf-zoom-level" class="text-xs font-medium w-8 sm:w-12 text-center">100%</span>
                             <button id="pdf-zoom-in" class="inline-flex items-center justify-center rounded-lg text-sm font-medium transition-colors hover:bg-slate-700 hover:text-slate-200 text-slate-300 h-8 w-8">
                                <i data-lucide="zoom-in" class="h-3 w-3"></i>
                             </button>
                             <!-- Progress indicator - hidden on mobile -->
                             <div class="hidden lg:flex items-center space-x-2 ml-2">
                                <div class="relative w-16 h-1.5 bg-slate-700 rounded-full overflow-hidden">
                                    <div id="reading-progress-bar" class="absolute top-0 left-0 h-full bg-blue-500 rounded-full transition-all duration-300" style="width: 0%"></div>
                                </div>
                                <span id="reading-progress-text" class="text-xs font-medium text-slate-400 w-8 text-center">0%</span>
                             </div>
                        </div>
                        
                        <!-- Right section - compact -->
                        <div class="flex items-center space-x-1 flex-shrink-0">
                             <span id="pdf-page-indicator" class="hidden sm:block text-xs font-medium text-slate-400 w-12 sm:w-16 text-center">1/1</span>
                             <button id="pdf-fit-width" class="hidden xl:inline-flex items-center justify-center rounded-lg text-sm font-medium transition-colors hover:bg-slate-700 hover:text-slate-200 text-slate-300 h-9 w-9">
                                <i data-lucide="move-horizontal" class="h-4 w-4"></i>
                             </button>
                             <button id="top-read-another-pdf-btn" class="inline-flex items-center justify-center rounded-lg text-sm font-medium transition-colors bg-purple-600 text-white hover:bg-purple-700 h-8 w-8 sm:h-9 sm:w-auto sm:px-4 sm:py-2 sm:gap-2">
                                <i data-lucide="x" class="h-4 w-4"></i>
                                <span class="hidden sm:inline">Exit</span>
                             </button>
                        </div>
                    </div>
                </div>
            </div>

            <div id="pdf-container" class="bg-slate-800 pt-16">
                <div id="pdf-viewer"></div>
            </div>
            <div id="loading-indicator" class="hidden fixed top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 p-4 bg-slate-900/80 backdrop-blur-sm rounded-lg border border-slate-700 shadow-lg z-50">
                <div class="flex items-center text-slate-300">
                    <div class="spinner h-5 w-5 border-2 border-slate-300 border-t-transparent rounded-full mr-3"></div>
                    <span id="loading-text"></span>
                </div>
            </div>
        </div>

        <div id="error-section" class="hidden fixed bottom-24 sm:bottom-4 left-1/2 -translate-x-1/2 w-auto bg-red-600/90 text-white p-4 rounded-lg shadow-lg z-[10000]">
            <p id="error-message"></p>
        </div>
    </main>

    <div id="sticky-audio-player" class="fixed bottom-0 left-0 right-0 z-[9999] bg-slate-900/80 backdrop-blur-xl border-t border-slate-700 transform translate-y-full transition-transform duration-300 ease-in-out">
        <!-- This is the player for larger screens -->
        <div class="hidden sm:block p-3 max-w-6xl mx-auto">
            <!-- Main controls row -->
            <div class="flex items-center justify-between gap-2 mb-3">
                <div class="flex items-center gap-2 flex-1 min-w-0">
                    <button id="sticky-rewind-btn" class="p-2 rounded-full bg-slate-700 hover:bg-slate-600 text-slate-300 transition-all flex-shrink-0">
                        <i data-lucide="rewind" class="h-5 w-5"></i>
                    </button>
                    <button id="sticky-play-pause-btn" class="p-2 rounded-full bg-blue-600 hover:bg-blue-700 text-white transition-all flex-shrink-0">
                        <i data-lucide="pause" class="h-5 w-5"></i>
                    </button>
                    <button id="sticky-forward-btn" class="p-2 rounded-full bg-slate-700 hover:bg-slate-600 text-slate-300 transition-all flex-shrink-0">
                        <i data-lucide="fast-forward" class="h-5 w-5"></i>
                    </button>
                    <div class="flex items-center gap-2 min-w-0">
                        <div class="text-xs text-slate-400 hidden lg:block">Voice:</div>
                        <select id="sticky-voice-select" class="bg-slate-800 text-white text-xs rounded-md px-2 py-1 border border-slate-700 focus:border-blue-500 focus:ring-0 outline-none appearance-none min-w-0 flex-shrink">
                            {% for key, model in models.items() %}<option value="{{ key }}" {% if key == 'edge-tts-andrew' %}selected{% endif %}>{{ model.name }}</option>{% endfor %}
                        </select>
                    </div>
                    <div class="flex items-center gap-2">
                        <div class="text-xs text-slate-400 hidden md:block">Speed:</div>
                        <select id="sticky-speed-select" class="bg-slate-800 text-white text-xs rounded-md px-2 py-1 border border-slate-700 focus:border-blue-500 focus:ring-0 outline-none appearance-none">
                            <option value="0.5">0.5x</option><option value="0.75">0.75x</option><option value="1.0" selected>1.0x</option><option value="1.25">1.25x</option><option value="1.5">1.5x</option><option value="2.0">2.0x</option>
                        </select>
                    </div>
                    <div class="hidden xl:flex items-center gap-2">
                        <div class="text-xs text-slate-400">Skip Headers:</div>
                        <label class="relative inline-flex items-center cursor-pointer">
                            <input type="checkbox" id="sticky-skip-patterns" class="sr-only peer">
                            <div class="w-9 h-5 bg-slate-700 peer-focus:outline-none peer-focus:ring-2 peer-focus:ring-blue-300/20 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-4 after:w-4 after:transition-all peer-checked:bg-blue-600"></div>
                        </label>
                    </div>
                </div>
                <button id="sticky-stop-btn" class="p-2 rounded-full bg-red-500/20 hover:bg-red-500/40 text-red-300 transition-all flex-shrink-0">
                    <i data-lucide="x" class="h-5 w-5"></i>
                </button>
            </div>
            
            <!-- Background Music Controls Row -->
            <div class="flex items-center gap-2 border-t border-slate-700/50 pt-3">
                <div class="flex items-center gap-2 flex-shrink-0">
                    <div class="text-xs text-slate-400">ðŸŽµ Background:</div>
                    <label class="relative inline-flex items-center cursor-pointer">
                        <input type="checkbox" id="background-music-toggle" class="sr-only peer">
                        <div class="w-9 h-5 bg-slate-700 peer-focus:outline-none peer-focus:ring-2 peer-focus:ring-purple-300/20 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-4 after:w-4 after:transition-all peer-checked:bg-purple-600"></div>
                    </label>
                </div>
                <div id="background-music-controls" class="hidden flex items-center gap-2 flex-1 min-w-0">
                    <select id="background-music-select" class="bg-slate-800 text-white text-xs rounded-md px-2 py-1 border border-slate-700 focus:border-purple-500 focus:ring-0 outline-none appearance-none min-w-0 flex-1 max-w-[200px]">
                        <option value="">Select Music</option>
                    </select>
                    <div class="flex items-center gap-1 flex-shrink-0">
                        <div class="text-xs text-slate-400">Vol:</div>
                        <input type="range" id="background-music-volume" min="0" max="50" value="10" class="w-16 h-1 bg-slate-700 rounded-lg appearance-none cursor-pointer slider">
                        <span id="background-volume-text" class="text-xs text-slate-400 w-6 text-center">10%</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- This is the player for mobile screens -->
        <div class="sm:hidden flex flex-col p-4 gap-4">
            <div class="flex items-center justify-between">
                 <div class="flex items-center gap-3">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" class="text-blue-500">
                        <path d="M2.75 12C2.75 11.5858 3.08579 11.25 3.5 11.25H4.25C4.66421 11.25 5 11.5858 5 12V16C5 16.4142 4.66421 16.75 4.25 16.75H3.5C3.08579 16.75 2.75 16.4142 2.75 16V12Z" fill="currentColor" />
                        <path d="M6.75 8C6.75 7.58579 7.08579 7.25 7.5 7.25H8.25C8.66421 7.25 9 7.58579 9 8V16C9 16.4142 8.66421 16.75 8.25 16.75H7.5C7.08579 16.75 6.75 16.4142 6.75 16V8Z" fill="currentColor" />
                        <path d="M10.75 10C10.75 9.58579 11.0858 9.25 11.5 9.25H12.25C12.6642 9.25 13 9.58579 13 10V16C13 16.4142 12.6642 16.75 12.25 16.75H11.5C11.0858 16.75 10.75 16.4142 10.75 16V10Z" fill="currentColor" />
                        <path d="M14.75 6C14.75 5.58579 15.0858 5.25 15.5 5.25H16.25C16.6642 5.25 17 5.58579 17 6V16C17 16.4142 16.6642 16.75 16.25 16.75H15.5C15.0858 16.75 14.75 16.4142 14.75 16V6Z" fill="currentColor" />
                        <path d="M18.75 9C18.75 8.58579 19.0858 8.25 19.5 8.25H20.25C20.6642 8.25 21 8.58579 21 9V16C21 16.4142 20.6642 16.75 20.25 16.75H19.5C19.0858 16.75 18.75 16.4142 18.75 16V9Z" fill="currentColor" />
                    </svg>
                                         <div class="flex items-center gap-2">
                        <div class="text-sm font-medium">Now Playing</div>
                        <div id="mobile-bg-music-status" class="hidden text-xs bg-purple-500/20 text-purple-300 px-2 py-0.5 rounded-full">ðŸŽµ BG</div>
                    </div>
                </div>
                 <button id="mobile-sticky-stop-btn" class="p-1.5 rounded-full text-slate-400 hover:bg-slate-700"><i data-lucide="x" class="h-5 w-5"></i></button>
            </div>
            <div class="flex items-center justify-between">
                <div class="relative">
                    <select id="mobile-speed-select" class="w-16 h-12 bg-slate-800 text-white text-sm font-bold rounded-full border border-slate-700 focus:border-blue-500 focus:ring-0 outline-none appearance-none text-center">
                        <option value="0.5">0.5x</option>
                        <option value="0.75">0.75x</option>
                        <option value="1.0" selected>1.0x</option>
                        <option value="1.25">1.25x</option>
                        <option value="1.5">1.5x</option>
                        <option value="2.0">2.0x</option>
                    </select>
                    <div class="absolute inset-y-0 right-1 flex items-center pointer-events-none">
                        <i data-lucide="chevron-down" class="h-3 w-3 text-slate-400"></i>
                    </div>
                </div>
                <div class="flex items-center gap-4">
                     <button id="mobile-rewind-btn" class="p-3 text-slate-300"><i data-lucide="rewind" class="h-6 w-6"></i></button>
                     <button id="mobile-play-pause-btn" class="w-16 h-16 flex items-center justify-center rounded-full bg-blue-600 text-white shadow-lg shadow-blue-500/30"><i data-lucide="pause" class="h-8 w-8"></i></button>
                     <button id="mobile-forward-btn" class="p-3 text-slate-300"><i data-lucide="fast-forward" class="h-6 w-6"></i></button>
                </div>
                <button id="mobile-options-btn" class="relative w-12 h-12 flex items-center justify-center rounded-full bg-slate-800">
                    <i data-lucide="more-horizontal" class="h-6 w-6"></i>
                    <div id="mobile-music-indicator" class="hidden absolute -top-1 -right-1 w-3 h-3 bg-purple-500 rounded-full border border-slate-900"></div>
                </button>
            </div>
             <!-- Mobile options panel -->
            <div id="mobile-options-panel" class="hidden bg-slate-800 rounded-lg p-4">
                <div class="space-y-4">
                    <div class="flex items-center justify-between">
                        <label for="mobile-voice-select" class="text-sm text-slate-400">Voice</label>
                        <select id="mobile-voice-select" class="bg-slate-700 text-white text-sm rounded-md px-3 py-1.5 border border-slate-600 focus:border-blue-500 focus:ring-0 outline-none appearance-none">
                             {% for key, model in models.items() %}<option value="{{ key }}" {% if key == 'edge-tts-andrew' %}selected{% endif %}>{{ model.name }}</option>{% endfor %}
                        </select>
                    </div>
                    <div class="flex items-center justify-between">
                        <label for="mobile-skip-patterns" class="text-sm text-slate-400">Skip Headers/Footers</label>
                        <label class="relative inline-flex items-center cursor-pointer">
                            <input type="checkbox" id="mobile-skip-patterns" class="sr-only peer">
                            <div class="w-11 h-6 bg-slate-700 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-blue-300/20 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-blue-600"></div>
                        </label>
                    </div>
                    <!-- Background Music Controls for Mobile -->
                    <div class="border-t border-slate-700 pt-4">
                        <div class="flex items-center justify-between mb-3">
                            <label for="mobile-background-music-toggle" class="text-sm text-slate-400">Background Music</label>
                            <label class="relative inline-flex items-center cursor-pointer">
                                <input type="checkbox" id="mobile-background-music-toggle" class="sr-only peer">
                                <div class="w-11 h-6 bg-slate-700 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-purple-300/20 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-purple-600"></div>
                            </label>
                        </div>
                        <div id="mobile-background-music-controls" class="hidden space-y-3">
                            <div class="flex items-center justify-between">
                                <label for="mobile-background-music-select" class="text-sm text-slate-400">Music</label>
                                <select id="mobile-background-music-select" class="bg-slate-700 text-white text-sm rounded-md px-3 py-1.5 border border-slate-600 focus:border-purple-500 focus:ring-0 outline-none appearance-none">
                                    <option value="">Select Music</option>
                                </select>
                            </div>
                            <div class="flex items-center justify-between">
                                <label for="mobile-background-music-volume" class="text-sm text-slate-400">Volume</label>
                                <div class="flex items-center gap-2">
                                    <input type="range" id="mobile-background-music-volume" min="0" max="50" value="10" class="w-20 h-1 bg-slate-700 rounded-lg appearance-none cursor-pointer slider">
                                    <span id="mobile-background-volume-text" class="text-xs text-slate-400 w-8">10%</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Hidden file inputs -->
    <input type="file" id="music-input" accept=".mp3,.wav,.m4a,.aac,.ogg,.flac" class="hidden">
    
    <!-- Audio elements -->
    <audio id="audio-player-element" style="display:none;"></audio>
    <audio id="background-music-element" style="display:none;" loop></audio>

    <script>
        // --- AUTHENTICATION CHECK --- //
        document.addEventListener('DOMContentLoaded', async () => {
            await checkAuthentication();
        });

        async function checkAuthentication() {
            const token = localStorage.getItem('auth_token');
            
            if (!token) {
                window.location.href = '/login';
                return;
            }

            try {
                const response = await fetch('/api/auth/verify', {
                    headers: {
                        'Authorization': `Bearer ${token}`
                    }
                });

                if (!response.ok) {
                    localStorage.removeItem('auth_token');
                    localStorage.removeItem('user_data');
                    window.location.href = '/login';
                    return;
                }

                const data = await response.json();
                if (data.success) {
                    // Store user data and initialize the app
                    localStorage.setItem('user_data', JSON.stringify(data.user));
                    displayUserInfo(data.user);
                    await initializeApp();
                } else {
                    window.location.href = '/login';
                }
            } catch (error) {
                console.error('Authentication check failed:', error);
                window.location.href = '/login';
            }
        }

        async function initializeApp() {
            lucide.createIcons();
            await loadUserPreferences();
            applyPreferencesToUI();
            setupEventListeners();
            initializeWebAudioPlayer();
            loadUserPDFs();
            loadBackgroundMusic();
            
            // Enhanced progress saving on page unload with multiple event listeners
            setupUnloadProgressSaving();
        }

        // Add authorization header to all API requests
        function makeAuthenticatedRequest(url, options = {}) {
            const token = localStorage.getItem('auth_token');
            const headers = {
                ...options.headers,
                'Authorization': `Bearer ${token}`
            };
            
            return fetch(url, {
                ...options,
                headers
            });
        }
        
        // --- GLOBAL STATE --- //
        let wordMap = [];
        let pdfDoc = null, pdfTotalPages = 0, pdfScale = 1.0;
        let currentChunk = null;
        let isPlaying = false;
        let currentFileId = null;
        let progressSaveInterval = null;
        let progressUpdateInterval = null;
        let audioCache = new Map(), gaplessPlayer = null, isPaused = false, currentPlaybackRate = 1.0, selectedModel = 'edge-tts-andrew';
        let currentViewingPage = 1;
        let isViewChanging = false;
        let hasUserInteracted = false;
        let skipPatterns = false; // Pattern filtering preference
        
        // Smart Auto-Scroll State
        let autoScrollEnabled = true;
        let isUserBrowsing = false;
        let browsePauseTimeout = null;
        let lastScrollTime = 0;
        let userScrollDetectionTimeout = null;
        
        // Rate limiting for progress updates
        let lastProgressUpdate = 0;
        const PROGRESS_UPDATE_COOLDOWN = 12000; // 12 seconds (5 requests per minute)

        // Background Music State
        let backgroundMusicFiles = [];
        let backgroundMusicEnabled = false;
        let currentBackgroundMusic = null;
        let backgroundMusicVolume = 0.1; // Default 10%
        
        // Background Music Buffering
        let bufferedBackgroundMusic = null; // Stores preloaded audio data
        let bufferedMusicId = null; // ID of the buffered music
        
        // Web Audio API for Mobile Safari Volume Control (background music only)
        let backgroundAudioContext = null;
        let backgroundGainNode = null;
        let backgroundSourceNode = null;
        
        // Wake Lock API to prevent screen from locking (mobile Safari compatibility)
        let wakeLock = null;
        let isWakeLockSupported = 'wakeLock' in navigator;
        

        

        
        // Detect mobile Safari for special handling (global scope)
        const isMobileSafari = /iPhone|iPad|iPod/.test(navigator.userAgent) && /Safari/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent);



        // Setup mobile volume slider with deferred attachment for hidden elements
        function setupMobileVolumeSlider() {
            const mobileVolumeSlider = $('mobile-background-music-volume');
            console.log('Setting up mobile volume slider, element found:', mobileVolumeSlider, 'isMobileSafari:', isMobileSafari);
            
            if (mobileVolumeSlider && !mobileVolumeSlider.hasVolumeListener) {
                // Enhanced volume change handler for mobile Safari
                const handleVolumeChange = async (e) => {
                    console.log('Mobile volume slider changed:', e.target.value, 'Event type:', e.type);
                    
                    if (isMobileSafari) {
                        // Initialize Web Audio API for volume control
                        await initMobileSafariAudioContext();
                        
                        // Apply volume using Web Audio API
                        setBackgroundMusicVolume(e.target.value);
                    } else {
                        setBackgroundMusicVolume(e.target.value);
                    }
                };
                
                // Add multiple event listeners for better mobile Safari compatibility
                mobileVolumeSlider.addEventListener('input', handleVolumeChange);
                mobileVolumeSlider.addEventListener('change', handleVolumeChange);
                
                // Additional touch events for mobile Safari
                if (isMobileSafari) {
                    mobileVolumeSlider.addEventListener('touchend', handleVolumeChange);
                    mobileVolumeSlider.addEventListener('mouseup', handleVolumeChange);
                }
                
                mobileVolumeSlider.hasVolumeListener = true;
                console.log('Mobile volume slider event listeners attached successfully');
            }
        }

        // Force volume application specifically for mobile Safari
        function forceMobileVolumeApplication(sliderValue) {
            if (!isMobileSafari) return;
            
            const percentage = (sliderValue / 50) * 100;
            const volumeDecimal = percentage / 100;
            
            const backgroundAudio = $('background-music-element');
            if (backgroundAudio && !backgroundAudio.paused) {
                console.log('Force applying mobile Safari volume:', volumeDecimal);
                backgroundAudio.volume = volumeDecimal;
                
                // Double-check and re-apply if needed
                setTimeout(() => {
                    if (Math.abs(backgroundAudio.volume - volumeDecimal) > 0.01) {
                        console.log('Mobile Safari volume mismatch, re-applying:', volumeDecimal);
                        backgroundAudio.volume = volumeDecimal;
                    }
                }, 50);
                
                // Additional verification with extended retry
                setTimeout(() => {
                    verifyMobileSafariVolume(volumeDecimal);
                }, 150);
            }
        }

        // Verify and ensure mobile Safari volume is correctly applied
        function verifyMobileSafariVolume(expectedVolume) {
            if (!isMobileSafari) return;
            
            const backgroundAudio = $('background-music-element');
            if (backgroundAudio && !backgroundAudio.paused) {
                const actualVolume = backgroundAudio.volume;
                const volumeDiff = Math.abs(actualVolume - expectedVolume);
                
                console.log(`Mobile Safari volume verification - Expected: ${expectedVolume}, Actual: ${actualVolume}, Diff: ${volumeDiff}`);
                
                if (volumeDiff > 0.02) { // More tolerance for mobile Safari
                    console.log('Mobile Safari volume verification failed, forcing correction');
                    backgroundAudio.volume = expectedVolume;
                    
                    // One more attempt after a longer delay
                    setTimeout(() => {
                        if (Math.abs(backgroundAudio.volume - expectedVolume) > 0.02) {
                            backgroundAudio.volume = expectedVolume;
                            console.log('Mobile Safari final volume correction attempt:', expectedVolume);
                        }
                    }, 300);
                } else {
                    console.log('Mobile Safari volume verification passed');
                }
            }
        }

        const $ = (id) => document.getElementById(id);

        function displayUserInfo(user) {
            const welcomeEl = $('user-welcome');
            welcomeEl.textContent = `Welcome, ${user.name || user.email}`;
        }

        function logout() {
            localStorage.removeItem('auth_token');
            localStorage.removeItem('user_data');
            window.location.href = '/login';
        }

        function setupEventListeners() {
            // Track user interactions for autoplay policy
            const markUserInteracted = () => { hasUserInteracted = true; };
            document.addEventListener('click', markUserInteracted, { once: true });
            document.addEventListener('keydown', markUserInteracted, { once: true });
            document.addEventListener('touchstart', markUserInteracted, { once: true });
            
            // Logout button
            $('logout-btn').addEventListener('click', logout);
            
            const uploadArea = $('upload-area');
            uploadArea.addEventListener('dragover', (e) => { e.preventDefault(); uploadArea.classList.add('dragover'); });
            uploadArea.addEventListener('dragleave', (e) => uploadArea.classList.remove('dragover'));
            uploadArea.addEventListener('drop', (e) => { e.preventDefault(); uploadArea.classList.remove('dragover'); if (e.dataTransfer.files.length) handleFile(e.dataTransfer.files[0]); });
            uploadArea.addEventListener('click', () => $('pdf-input').click());
            $('pdf-input').addEventListener('change', (e) => { if (e.target.files.length) handleFile(e.target.files[0]); });
            
            // Desktop player controls
            $('sticky-rewind-btn').addEventListener('click', async () => {
                console.log('\n\nðŸ”´ðŸ”´ðŸ”´ REWIND BUTTON CLICKED ðŸ”´ðŸ”´ðŸ”´');
                try { await seek(-10); } catch (e) { console.error('Seek error:', e); }
                console.log('ðŸ”´ðŸ”´ðŸ”´ REWIND BUTTON HANDLER COMPLETE ðŸ”´ðŸ”´ðŸ”´\n\n');
            });
            $('sticky-play-pause-btn').addEventListener('click', togglePlayPause);
            $('sticky-forward-btn').addEventListener('click', async () => {
                console.log('\n\nðŸ”µðŸ”µðŸ”µ FORWARD BUTTON CLICKED ðŸ”µðŸ”µðŸ”µ');
                try { await seek(10); } catch (e) { console.error('Seek error:', e); }
                console.log('ðŸ”µðŸ”µðŸ”µ FORWARD BUTTON HANDLER COMPLETE ðŸ”µðŸ”µðŸ”µ\n\n');
            });
            $('sticky-stop-btn').addEventListener('click', closePlayer);
            $('sticky-speed-select').addEventListener('change', (e) => changePlaybackRate(e.target.value));
            $('sticky-voice-select').addEventListener('change', (e) => handleVoiceChange(e.target.value));
            $('sticky-skip-patterns').addEventListener('change', (e) => handleSkipPatternsChange(e.target.checked));

            // Top bar controls
            $('pdf-start-reading').addEventListener('click', () => playFromWord(0));
            $('top-go-to-current').addEventListener('click', goToCurrentHighlight);
            $('pdf-zoom-in').addEventListener('click', () => { changeZoom(0.25); });
            $('pdf-zoom-out').addEventListener('click', () => { changeZoom(-0.25); });
            $('pdf-fit-width').addEventListener('click', async () => { await fitToWidth(); await rerenderVisiblePages(); });
            $('top-read-another-pdf-btn').addEventListener('click', resetToUpload);

            // Mobile player controls
            $('mobile-play-pause-btn').addEventListener('click', togglePlayPause);
            $('mobile-sticky-stop-btn').addEventListener('click', closePlayer);
            $('mobile-speed-select').addEventListener('change', (e) => changePlaybackRate(e.target.value));
            $('mobile-voice-select').addEventListener('change', (e) => handleVoiceChange(e.target.value));
            $('mobile-skip-patterns').addEventListener('change', (e) => handleSkipPatternsChange(e.target.checked));
            $('mobile-options-btn').addEventListener('click', () => {
                $('mobile-options-panel').classList.toggle('hidden');
                // Setup mobile volume slider when panel becomes visible
                setTimeout(setupMobileVolumeSlider, 10);
            });
            $('mobile-rewind-btn').addEventListener('click', async () => {
                console.log('\n\nðŸ”´ðŸ”´ðŸ”´ MOBILE REWIND BUTTON CLICKED ðŸ”´ðŸ”´ðŸ”´');
                try { await seek(-10); } catch (e) { console.error('Seek error:', e); }
                console.log('ðŸ”´ðŸ”´ðŸ”´ MOBILE REWIND BUTTON HANDLER COMPLETE ðŸ”´ðŸ”´ðŸ”´\n\n');
            });
            $('mobile-forward-btn').addEventListener('click', async () => {
                console.log('\n\nðŸ”µðŸ”µðŸ”µ MOBILE FORWARD BUTTON CLICKED ðŸ”µðŸ”µðŸ”µ');
                try { await seek(10); } catch (e) { console.error('Seek error:', e); }
                console.log('ðŸ”µðŸ”µðŸ”µ MOBILE FORWARD BUTTON HANDLER COMPLETE ðŸ”µðŸ”µðŸ”µ\n\n');
            });

            // Background music controls
            $('upload-music-btn').addEventListener('click', () => $('music-input').click());
            $('music-input').addEventListener('change', (e) => { if (e.target.files.length) handleMusicUpload(e.target.files[0]); });
            $('background-music-toggle').addEventListener('change', (e) => toggleBackgroundMusic(e.target.checked));
            $('background-music-select').addEventListener('change', (e) => selectBackgroundMusic(e.target.value));
            $('background-music-volume').addEventListener('input', (e) => {
                console.log('Desktop volume slider changed:', e.target.value);
                setBackgroundMusicVolume(e.target.value);
            });
            
            // Mobile background music controls
            $('mobile-background-music-toggle').addEventListener('change', (e) => toggleBackgroundMusic(e.target.checked));
            $('mobile-background-music-select').addEventListener('change', (e) => selectBackgroundMusic(e.target.value));
            

            
            // Try to setup mobile volume slider immediately
            setupMobileVolumeSlider();
            
            // Also setup mobile volume slider when mobile options panel is opened
            // (Add to existing mobile options button event listener)

            document.addEventListener('keydown', (e) => { 
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') return;
                if (e.key === ' ') { 
                    e.preventDefault();
                    togglePlayPause(); 
                }
            });

            // Default preferences controls
            $('test-voice-btn').addEventListener('click', testVoiceAndSpeed);
            $('save-default-prefs-btn').addEventListener('click', saveDefaultPreferences);
            $('default-voice-select').addEventListener('change', updateDefaultPreferencesUI);
            $('default-speed-select').addEventListener('change', updateDefaultPreferencesUI);
            $('default-skip-patterns').addEventListener('change', updateDefaultPreferencesUI);
        }

        // --- PDF PROCESSING & RENDERING --- //
        async function handleFile(file) {
            if (!file.type.includes('pdf')) return showError('Please select a PDF file.');
            await stopPlayback();
            resetPdfState();

            try {
                await processPDFFile(file);
            } catch (error) {
                showError('Failed to process PDF: ' + error.message);
                console.error(error);
                resetToUpload();
            }
        }
        
        async function renderInitialView() {
            showLoading(`Rendering initial pages...`);
            const viewer = $('pdf-viewer');
            viewer.innerHTML = '';
            
            const numPagesToRender = Math.min(5, pdfTotalPages);

            for (let pageNum = 1; pageNum <= numPagesToRender; pageNum++) {
                await renderSinglePage(pageNum, viewer);
            }

            hideLoading();
            if (isPlaying || isPaused) updateHighlighting();
        }

        async function renderAllPages() {
            showLoading(`Rendering ${pdfTotalPages} pages...`);
            const viewer = $('pdf-viewer');
            viewer.innerHTML = '';

            for (let pageNum = 1; pageNum <= pdfTotalPages; pageNum++) {
                await renderSinglePage(pageNum, viewer);
            }

            hideLoading();
            if (isPlaying || isPaused) updateHighlighting();
        }

        async function renderSinglePage(pageNum, viewer) {
             try {
                const page = await pdfDoc.getPage(pageNum);
                // Ensure we always use the current pdfScale value and log it for debugging
                const currentScale = pdfScale; // Capture scale at render time
                console.log(`Rendering page ${pageNum} with scale: ${currentScale}`);
                const viewport = page.getViewport({ scale: currentScale });

                const pageDiv = document.createElement('div');
                pageDiv.className = 'pdf-page';
                pageDiv.dataset.pageNum = pageNum;
                pageDiv.dataset.renderScale = currentScale; // Store scale used for this page
                pageDiv.style.width = `${viewport.width}px`;
                pageDiv.style.height = `${viewport.height}px`;

                const canvas = document.createElement('canvas');
                canvas.width = viewport.width;
                canvas.height = viewport.height;
                // Store the pixel ratio for crisp rendering
                const context = canvas.getContext('2d');
                const devicePixelRatio = window.devicePixelRatio || 1;
                const displayWidth = viewport.width;
                const displayHeight = viewport.height;
                
                canvas.width = displayWidth * devicePixelRatio;
                canvas.height = displayHeight * devicePixelRatio;
                canvas.style.width = displayWidth + 'px';
                canvas.style.height = displayHeight + 'px';
                
                context.scale(devicePixelRatio, devicePixelRatio);
                pageDiv.appendChild(canvas);

                const textLayer = document.createElement('div');
                textLayer.className = 'text-layer';
                pageDiv.appendChild(textLayer);
                
                viewer.appendChild(pageDiv);

                await page.render({ canvasContext: context, viewport }).promise;

                const wordsOnPage = wordMap.filter(w => w.page === pageNum);
                if (wordsOnPage.length > 0) {
                    const originalPage = {width: wordsOnPage[0].page_width, height: wordsOnPage[0].page_height};
                    const scaleX = viewport.width / originalPage.width;
                    const scaleY = viewport.height / originalPage.height;

                    for (const word of wordsOnPage) {
                        const span = document.createElement('span');
                        span.className = 'text-span';
                        span.dataset.wordIndex = word.index;
                        
                        const style = span.style;
                        style.left = `${word.x * scaleX}px`;
                        style.top = `${word.y * scaleY}px`;
                        style.width = `${word.width * scaleX}px`;
                        style.height = `${word.height * scaleY}px`;

                        span.addEventListener('click', () => {
                            playFromWord(word.index);
                            updateProgressWithRateLimit(word.index);
                        });
                        textLayer.appendChild(span);
                    }
                }
                
                console.log(`Successfully rendered page ${pageNum} with scale ${currentScale}`);
            } catch(e) {
                console.error(`Failed to render page ${pageNum}`, e);
                showError(`Error rendering page ${pageNum}.`);
            }
        }

        async function fitToWidth() {
            if (!pdfDoc) return;
            const page = await pdfDoc.getPage(1);
            const containerWidth = $('pdf-container').clientWidth;
            const pageViewport = page.getViewport({ scale: 1 });
            
            // Calculate scale but limit it to reasonable bounds
            let calculatedScale = containerWidth / pageViewport.width;
            
            // Prevent excessive zoom - limit to max 150% for better readability
            calculatedScale = Math.min(calculatedScale, 1.5);
            // Also ensure minimum zoom of 50%
            calculatedScale = Math.max(calculatedScale, 0.5);
            
            pdfScale = calculatedScale;
            updateZoomLevel();
        }

        function setupScrollListener() {
            const viewer = $('pdf-viewer');
            let scrollTimeout;
            
            // Listen to both viewer scroll and window scroll
            const handleScroll = async () => {
                if (isViewChanging) return;
                
                // Detect user browsing when they scroll during playback
                if (!isViewChanging && (isPlaying || isPaused)) {
                    detectUserBrowsing();
                }

                const { scrollTop, scrollHeight, clientHeight } = viewer;
                if (scrollHeight - scrollTop - clientHeight < clientHeight * 1.5) { // Load when 1.5 screens away from bottom
                    isViewChanging = true;
                    await maintainSlidingWindow();
                    isViewChanging = false;
                }
                updateCurrentViewingPage();
            };
            
            viewer.addEventListener('scroll', handleScroll, { passive: true });
            window.addEventListener('scroll', handleScroll, { passive: true });
            
            // Also detect browsing on touch/mouse events that might lead to scrolling
            viewer.addEventListener('touchstart', () => {
                if (isPlaying || isPaused) {
                    detectUserBrowsing();
                }
            }, { passive: true });
            
            viewer.addEventListener('mousedown', () => {
                if (isPlaying || isPaused) {
                    detectUserBrowsing();
                }
            }, { passive: true });
            
            // Also update page on initial load
            setTimeout(() => {
                updateCurrentViewingPage();
            }, 500);
        }

        function updateCurrentViewingPage() {
            const viewer = $('pdf-viewer');
            const viewerRect = viewer.getBoundingClientRect();
            const viewerMiddle = viewerRect.top + (viewerRect.height / 3);

            const pageElements = document.querySelectorAll('[data-page-num]');
            for (const pageEl of pageElements) {
                const pageRect = pageEl.getBoundingClientRect();
                if (pageRect.top <= viewerMiddle && pageRect.bottom >= viewerMiddle) {
                    currentViewingPage = parseInt(pageEl.dataset.pageNum);
                    updatePageIndicator();
                    break;
                }
            }
        }

        function updatePageIndicator() {
            if (pdfDoc) {
                $('pdf-page-indicator').textContent = `Page ${currentViewingPage} / ${pdfTotalPages}`;
                // Progress is now tracked via audio chunks, not page changes
            }
        }

        async function maintainSlidingWindow() {
            try {
                const pageElements = document.querySelectorAll('.pdf-page');
                const lastRenderedPage = pageElements.length > 0
                    ? Array.from(pageElements).reduce((max, p) => Math.max(max, parseInt(p.dataset.pageNum)), 0)
                    : 0;

                if (lastRenderedPage >= pdfTotalPages) return;

                const nextPageToLoad = lastRenderedPage + 1;
                const endPageToLoad = Math.min(lastRenderedPage + 3, pdfTotalPages); // Load 3 more pages

                if (nextPageToLoad > endPageToLoad) return;

                showLoading(`Loading pages ${nextPageToLoad}-${endPageToLoad}...`);
                const viewer = $('pdf-viewer');
                
                // Use document fragment for batch DOM updates
                const fragment = document.createDocumentFragment();
                for (let pageNum = nextPageToLoad; pageNum <= endPageToLoad; pageNum++) {
                    if (!document.querySelector(`[data-page-num="${pageNum}"]`)) {
                        await renderSinglePage(pageNum, fragment);
                    }
                }
                
                // Append all new pages at once
                if (fragment.children.length > 0) {
                    viewer.appendChild(fragment);
                }
                
                hideLoading();
            } catch(e) {
                console.error("Error in maintainSlidingWindow: ", e);
                hideLoading();
            }
        }

        async function scrollToWord(wordIndex, forceScroll = false) {
            if (isViewChanging) return;
            
            // Check if auto-scroll is enabled and user is not browsing, or if forced
            if (!forceScroll && autoScrollEnabled && isUserBrowsing) {
                console.log('Auto-scroll paused - user is browsing');
                return;
            }

            const wordInfo = wordMap[wordIndex];
            if (!wordInfo) return;

            const targetPageNum = wordInfo.page;
            const viewer = $('pdf-viewer');
            let pageElement = viewer.querySelector(`[data-page-num="${targetPageNum}"]`);

            if (!pageElement) {
                isViewChanging = true;
                try {
                    showLoading(`Jumping to page ${targetPageNum}...`);
                    
                    viewer.innerHTML = '';
                    
                    const startPage = Math.max(1, targetPageNum - 2);
                    const endPage = Math.min(pdfTotalPages, targetPageNum + 2);

                    // Use a document fragment to build all pages before adding to DOM
                    const fragment = document.createDocumentFragment();
                    for (let i = startPage; i <= endPage; i++) {
                        await renderSinglePage(i, fragment);
                    }
                    viewer.appendChild(fragment);

                    if (isPlaying || isPaused) updateHighlighting();
                    
                    hideLoading();
                } finally {
                    isViewChanging = false;
                }
            }
            
            // Wait a tick to ensure DOM is updated before scrolling
            setTimeout(() => {
                const wordSpan = document.querySelector(`.text-span[data-word-index="${wordIndex}"]`);
                if (wordSpan) {
                    wordSpan.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    currentViewingPage = targetPageNum;
                    updatePageIndicator();
                }
            }, 50);
        }

        async function goToCurrentHighlight() {
            if (!currentChunk) return showError('Nothing is playing.');
            const firstWordIndex = currentChunk.startIndex;
            
            // Resume auto-scroll when user manually goes to current
            resumeAutoScroll();
            
            // Force scroll even if auto-scroll is paused
            await scrollToWord(firstWordIndex, true);
        }
        
        // --- SMART AUTO-SCROLL FUNCTIONS --- //
        function detectUserBrowsing() {
            lastScrollTime = Date.now();
            
            // Clear existing timeout
            if (userScrollDetectionTimeout) {
                clearTimeout(userScrollDetectionTimeout);
            }
            
            // If auto-scroll is enabled and we're playing, mark as user browsing
            if (autoScrollEnabled && (isPlaying || isPaused)) {
                if (!isUserBrowsing) {
                    isUserBrowsing = true;
                    console.log('User browsing detected - auto-scroll paused');
                    updateGoToCurrentButton();
                }
                
                // Clear any existing resume timeout
                if (browsePauseTimeout) {
                    clearTimeout(browsePauseTimeout);
                }
                
                // Set timeout to resume auto-scroll after 15 seconds of inactivity
                browsePauseTimeout = setTimeout(() => {
                    if (isUserBrowsing) {
                        resumeAutoScroll();
                        console.log('Auto-scroll resumed after inactivity');
                    }
                }, 15000); // 15 seconds
            }
        }
        
        function resumeAutoScroll() {
            if (isUserBrowsing) {
                isUserBrowsing = false;
                console.log('Auto-scroll resumed manually');
                
                // Clear the inactivity timeout
                if (browsePauseTimeout) {
                    clearTimeout(browsePauseTimeout);
                    browsePauseTimeout = null;
                }
                
                updateGoToCurrentButton();
                
                // Immediately scroll to current position if playing
                if (currentChunk && (isPlaying || isPaused)) {
                    scrollToWord(currentChunk.startIndex);
                }
            }
        }
        
        function updateGoToCurrentButton() {
            const goToCurrentBtn = $('top-go-to-current');
            if (!goToCurrentBtn) return;
            
            if (isUserBrowsing && (isPlaying || isPaused)) {
                // Show the button when user is browsing during playback
                goToCurrentBtn.classList.remove('hidden');
                goToCurrentBtn.classList.add('flex');
                
                // Update button text to indicate auto-scroll is paused
                const buttonText = goToCurrentBtn.querySelector('span');
                if (buttonText) {
                    buttonText.textContent = 'Go to Current';
                }
            } else if (currentChunk && (isPlaying || isPaused)) {
                // Hide or show based on whether we're playing
                goToCurrentBtn.classList.remove('hidden');
                goToCurrentBtn.classList.add('flex');
                
                // Reset button text
                const buttonText = goToCurrentBtn.querySelector('span');
                if (buttonText) {
                    buttonText.textContent = 'Go to Current';
                }
            } else {
                // Hide when not playing
                goToCurrentBtn.classList.add('hidden');
                goToCurrentBtn.classList.remove('flex');
            }
        }

        // --- AUDIO PLAYBACK & CHUNKING --- //
        function getChunkForWord(wordIndex) {
            console.log(`getChunkForWord called with wordIndex: ${wordIndex}, wordMap.length: ${wordMap.length}`);
            if (wordIndex >= wordMap.length) {
                console.log('wordIndex >= wordMap.length, returning null');
                return null;
            }

            const startWord = wordMap[wordIndex];
            let startIndex = wordIndex;
            let endIndex = startIndex;
            
            // Limits for safety
            const maxCharacters = 9500; // Leave some buffer below the 10,000 limit
            const maxWordsPerChunk = 400; // Maximum words per chunk (increased for paragraphs)
            
            // Try paragraph-based chunking first
            if (startWord.paragraph_id !== undefined) {
                endIndex = getEndOfParagraph(startIndex);
                console.log(`Using paragraph-based chunking: paragraph ${startWord.paragraph_id}`);
            } else {
                // Fallback to sentence-based chunking if no paragraph data
                console.log('No paragraph data available, falling back to sentence-based chunking');
                endIndex = getSentenceBasedEnd(startIndex);
            }
            
            // Apply safety limits
            const wordsInChunk = wordMap.slice(startIndex, endIndex + 1);
            const text = wordsInChunk.map(w => w.text).join(' ');
            
            // Check if chunk exceeds limits
            if (text.length > maxCharacters || wordsInChunk.length > maxWordsPerChunk) {
                console.log(`Chunk too large (${text.length} chars, ${wordsInChunk.length} words), applying limits`);
                endIndex = applySafetyLimits(startIndex, maxCharacters, maxWordsPerChunk);
            }
            
            const finalWordsInChunk = wordMap.slice(startIndex, endIndex + 1);
            const finalText = finalWordsInChunk.map(w => w.text).join(' ');
            
            console.log(`Generated chunk from ${startIndex} to ${endIndex}: "${finalText.substring(0, 100)}..." (${finalText.length} characters, ${finalWordsInChunk.length} words, paragraph: ${startWord.paragraph_id || 'N/A'})`);
            
            return {
                startIndex: startIndex,
                endIndex: endIndex,
                text: finalText,
                id: `chunk-${startIndex}`,
                paragraphId: startWord.paragraph_id
            };
        }
        
        function getStartOfParagraph(wordIndex) {
            // Find the FIRST word of the paragraph that contains wordIndex
            const targetWord = wordMap[wordIndex];
            const targetParagraphId = targetWord.paragraph_id;
            
            // Search backwards to find the first word with this paragraph ID
            for (let i = wordIndex; i >= 0; i--) {
                const word = wordMap[i];
                
                // If we've moved to a different paragraph, the start is i+1
                if (word.paragraph_id !== targetParagraphId) {
                    return i + 1;
                }
                
                // If we reach the beginning of the document
                if (i === 0) {
                    return 0;
                }
            }
            
            return wordIndex; // Fallback
        }
        
        function getEndOfParagraph(startIndex) {
            const startWord = wordMap[startIndex];
            const targetParagraphId = startWord.paragraph_id;
            
            // Find the end of the current paragraph
            for (let i = startIndex; i < wordMap.length; i++) {
                const word = wordMap[i];
                
                // If we've moved to a different paragraph, stop at previous word
                if (word.paragraph_id !== targetParagraphId) {
                    return i - 1;
                }
                
                // If this word is marked as paragraph end, include it and stop
                if (word.paragraph_end) {
                    return i;
                }
            }
            
            // If we reach the end of the document, return the last word
            return wordMap.length - 1;
        }
        
        function getSentenceBasedEnd(startIndex) {
            // Fallback to the old sentence-based logic
            let endIndex = startIndex;
            let sentenceCount = 0;
            const targetSentenceCount = 3;
            
            for (let i = startIndex; i < wordMap.length; i++) {
                endIndex = i;
                const wordText = wordMap[i].text;
                
                // Check for sentence endings
                if (wordText.match(/[.?!]\s*$/)) {
                    sentenceCount++;
                    if (sentenceCount >= targetSentenceCount) {
                        break;
                    }
                }
            }
            
            return endIndex;
        }
        
        function applySafetyLimits(startIndex, maxCharacters, maxWordsPerChunk) {
            let endIndex = startIndex;
            
            for (let i = startIndex; i < wordMap.length; i++) {
                const wordsInChunk = wordMap.slice(startIndex, i + 1);
                const text = wordsInChunk.map(w => w.text).join(' ');
                
                // If adding this word would exceed limits, stop at previous word
                if (text.length > maxCharacters || wordsInChunk.length > maxWordsPerChunk) {
                    break;
                }
                
                endIndex = i;
            }
            
            return endIndex;
        }

        async function playFromWord(wordIndex) {
            console.log(`playFromWord called with wordIndex: ${wordIndex}`);
            // Ensure complete stop before starting new playback
            if (isPlaying || isPaused) {
                await stopPlayback();
                // Wait a bit to ensure the stop is complete
                await new Promise(resolve => setTimeout(resolve, 100));
            }
            
            const chunk = getChunkForWord(wordIndex);
            console.log('Chunk returned from getChunkForWord:', chunk);
            if (!chunk) return showError('Audio chunk not found for this word.');
            
            currentChunk = chunk;
            
            // Reset auto-scroll state when starting playback
            isUserBrowsing = false;
            if (browsePauseTimeout) {
                clearTimeout(browsePauseTimeout);
                browsePauseTimeout = null;
            }
            
            showPlayer();
            await scrollToWord(wordIndex, true); // Force scroll for initial playback
            
            try {
                // Ensure audio player is initialized only once
                if (!gaplessPlayer) {
                    initializeWebAudioPlayer();
                }
                
                const audioUrl = await loadChunk(chunk);
                
                // Only set playing state after audio starts successfully
                await gaplessPlayer.play(audioUrl, chunk.id);
                
                // Now that audio is playing, update state
                isPlaying = true;
                isPaused = false;
                
                updatePlayPauseButtons('pause');
                updateHighlighting();
                
                // Start progress tracking only after successful start
                startProgressTracking();
                
                // Start background music if enabled
                if (backgroundMusicEnabled && currentBackgroundMusic) {
                    await playBackgroundMusic();
                }
                
                const nextChunkStartIndex = chunk.endIndex + 1;
                if (nextChunkStartIndex < wordMap.length) {
                    preloadNextChunk(nextChunkStartIndex);
                }
                
                // Preload previous chunks for seamless rewinding
                const prevChunkStartIndex = chunk.startIndex - 1;
                if (prevChunkStartIndex >= 0) {
                    preloadPreviousChunks(prevChunkStartIndex);
                }
            } catch (error) { 
                showError('Playback failed: ' + error.message); 
                await stopPlayback(); 
            }
        }

        async function playNextChunk() {
            if (!currentChunk) { stopPlayback(); return; }
            const nextChunkStartIndex = currentChunk.endIndex + 1;
            if (nextChunkStartIndex >= wordMap.length) {
                stopPlayback();
                return;
            }
            
            const nextChunk = getChunkForWord(nextChunkStartIndex);
            if (!nextChunk) {
                stopPlayback();
                return;
            }
            
            currentChunk = nextChunk;
            updateHighlighting();
            await scrollToWord(currentChunk.startIndex);

            try {
                const audioUrl = await loadChunk(nextChunk);
                await gaplessPlayer.play(audioUrl, nextChunk.id);

                const subsequentChunkIndex = nextChunk.endIndex + 1;
                if (subsequentChunkIndex < wordMap.length) {
                    preloadNextChunk(subsequentChunkIndex);
                }
                
                // Preload previous chunks for seamless rewinding
                const prevChunkStartIndex = nextChunk.startIndex - 1;
                if (prevChunkStartIndex >= 0) {
                    preloadPreviousChunks(prevChunkStartIndex);
                }
            } catch (error) {
                showError('Playback failed: ' + error.message);
                stopPlayback();
            }
        }

        async function togglePlayPause() {
            if (!currentChunk) return;
            if (isPlaying && !isPaused) {
                if (gaplessPlayer) { 
                    isPaused = true; 
                    isPlaying = false; 
                    gaplessPlayer.pause(); 
                    updatePlayPauseButtons('play'); 
                    // Save progress when pausing
                    saveReadingProgress();
                    stopProgressTracking();
                }
            } else if (isPaused) {
                if (gaplessPlayer) { 
                    try {
                        await gaplessPlayer.resume(); 
                        isPaused = false; 
                        isPlaying = true; 
                        updatePlayPauseButtons('pause');
                        // Resume progress tracking
                        startProgressTracking();
                    } catch (error) {
                        showError('Failed to resume playback: ' + error.message);
                        await stopPlayback();
                    }
                }
            }
        }
        
        function closePlayer() {
            // Save progress before closing player
            if (currentChunk) {
                saveReadingProgress();
            }
            stopProgressTracking();
            hidePlayer();
            stopPlayback();
        }

        async function stopPlayback() {
            // Save progress before stopping
            if (currentChunk) {
                saveReadingProgress();
            }
            stopProgressTracking();
            
            isPlaying = false; isPaused = false; currentChunk = null;
            
            // Reset auto-scroll state
            isUserBrowsing = false;
            if (browsePauseTimeout) {
                clearTimeout(browsePauseTimeout);
                browsePauseTimeout = null;
            }
            
            if (gaplessPlayer) gaplessPlayer.stop();
            updatePlayPauseButtons('play');
            updateHighlighting();
        }

        async function loadChunk(chunk, showIndicator = true) {
            const cacheKey = `${chunk.id}-${selectedModel}`;
            
            // Check for direct cache hit
            if (audioCache.has(cacheKey)) {
                console.log(`Cache hit for chunk ${chunk.id}`);
                return audioCache.get(cacheKey);
            }
            
            // For playback chunks, always generate individual audio to ensure proper timing and highlighting
            // The preload optimization is only for background caching, not for actual playback
            if (showIndicator) showLoading('Generating audio...');
            
            try {
                const response = await makeAuthenticatedRequest('/api/generate-audio', {
                    method: 'POST', 
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ text: chunk.text, model: selectedModel })
                });

                if (!response.ok) throw new Error((await response.json()).error || 'API Error');
                
                const data = await response.json();
                const blob = new Blob([Uint8Array.from(atob(data.audio_data), c => c.charCodeAt(0))], { type: 'audio/wav' });
                const url = URL.createObjectURL(blob);
                audioCache.set(cacheKey, url);
                console.log(`Generated and cached new audio for chunk ${chunk.id} (${chunk.text.length} chars)`);
                return url;
            } finally {
                if (showIndicator) hideLoading();
            }
        }



        async function preloadNextChunk(wordIndex) {
            // Generate optimized chunk for preloading
            const optimizedChunk = getOptimalChunkForPreload(wordIndex);
            if (!optimizedChunk) return;
            
            // Check if we already have this optimized chunk cached
            const optimizedCacheKey = `${optimizedChunk.id}-${selectedModel}`;
            if (audioCache.has(optimizedCacheKey)) {
                console.log(`Optimized chunk already cached: ${optimizedChunk.id}`);
                return;
            }
            
            // Also preload individual paragraph chunks that will be needed for playback
            const individualChunksToPreload = getIndividualChunksFromOptimized(optimizedChunk);
            
            // Check if all individual chunks are already cached
            const allIndividualsCached = individualChunksToPreload.every(chunk => 
                audioCache.has(`${chunk.id}-${selectedModel}`)
            );
            
            if (allIndividualsCached) {
                console.log(`All individual chunks already cached for range ${wordIndex}`);
                return;
            }
            
            // If optimized chunk is just one paragraph, load individual chunk instead
            if (optimizedChunk.paragraphsIncluded === 1) {
                const individualChunk = getChunkForWord(wordIndex);
                if (individualChunk && !audioCache.has(`${individualChunk.id}-${selectedModel}`)) {
                    await loadChunk(individualChunk, false);
                }
                return;
            }
            
            // For multi-paragraph optimized chunks, load individual chunks for proper playback timing
            console.log(`Preloading ${individualChunksToPreload.length} individual chunks for seamless playback`);
            for (const chunk of individualChunksToPreload) {
                if (!audioCache.has(`${chunk.id}-${selectedModel}`)) {
                    await loadChunk(chunk, false);
                }
            }
        }

        async function preloadPreviousChunks(wordIndex) {
            console.log(`[PRELOAD PREVIOUS] Starting for wordIndex: ${wordIndex}`);
            // Preload previous chunks for seamless rewinding
            if (wordIndex < 0) {
                console.log('[PRELOAD PREVIOUS] wordIndex < 0, returning');
                return;
            }
            
            const BACKWARD_BUFFER_SIZE = 2; // Number of previous chunks to keep buffered
            
            // Get the previous chunks (going backwards by full paragraphs)
            const chunksToPreload = [];
            let currentIndex = wordIndex;
            
            for (let i = 0; i < BACKWARD_BUFFER_SIZE && currentIndex >= 0; i++) {
                console.log(`[PRELOAD PREVIOUS] Iteration ${i}, getting chunk for index ${currentIndex}`);
                
                // Find the FIRST word of the paragraph containing currentIndex
                // This ensures we get full paragraphs, not overlapping chunks
                const paragraphStartIndex = getStartOfParagraph(currentIndex);
                console.log(`[PRELOAD PREVIOUS] Paragraph starts at word ${paragraphStartIndex}`);
                
                const chunk = getChunkForWord(paragraphStartIndex);
                if (!chunk) {
                    console.log(`[PRELOAD PREVIOUS] No chunk found for index ${paragraphStartIndex}, breaking`);
                    break;
                }
                
                console.log(`[PRELOAD PREVIOUS] Found full paragraph chunk: ${chunk.id} (${chunk.startIndex}-${chunk.endIndex})`);
                chunksToPreload.push(chunk);
                
                // Move to the word before the START of this paragraph (to get the previous paragraph)
                currentIndex = paragraphStartIndex - 1;
                console.log(`[PRELOAD PREVIOUS] Next currentIndex: ${currentIndex}`);
            }
            
            // Preload all chunks that aren't already cached
            console.log(`[PRELOAD PREVIOUS] Preloading ${chunksToPreload.length} previous chunks for seamless rewinding`);
            for (const chunk of chunksToPreload) {
                const cacheKey = `${chunk.id}-${selectedModel}`;
                const isCached = audioCache.has(cacheKey);
                console.log(`[PRELOAD PREVIOUS] Chunk ${chunk.id}: cached=${isCached}`);
                if (!isCached) {
                    console.log(`[PRELOAD PREVIOUS] Loading chunk ${chunk.id}...`);
                    await loadChunk(chunk, false);
                    console.log(`[PRELOAD PREVIOUS] Chunk ${chunk.id} loaded`);
                }
            }
            console.log('[PRELOAD PREVIOUS] Complete');
        }

        function getIndividualChunksFromOptimized(optimizedChunk) {
            const chunks = [];
            let currentIndex = optimizedChunk.startIndex;
            
            while (currentIndex <= optimizedChunk.endIndex && currentIndex < wordMap.length) {
                const chunk = getChunkForWord(currentIndex);
                if (!chunk) break;
                
                chunks.push(chunk);
                currentIndex = chunk.endIndex + 1;
            }
            
            return chunks;
        }

        function getOptimalChunkForPreload(wordIndex) {
            console.log(`getOptimalChunkForPreload called with wordIndex: ${wordIndex}`);
            if (wordIndex >= wordMap.length) {
                console.log('wordIndex >= wordMap.length, returning null');
                return null;
            }

            const MIN_WORDS_FOR_CACHING = 100; // Minimum words to cache for seamless playback
            const maxCharacters = 9500; // Stay below API limit
            const maxWordsPerChunk = 400; // Maximum words per chunk
            
            let startIndex = wordIndex;
            let endIndex = startIndex;
            let totalWords = 0;
            let paragraphsIncluded = 0;
            
            // Start with the first paragraph
            const startWord = wordMap[startIndex];
            if (startWord.paragraph_id !== undefined) {
                endIndex = getEndOfParagraph(startIndex);
                totalWords = endIndex - startIndex + 1;
                paragraphsIncluded = 1;
                
                console.log(`Initial paragraph ${startWord.paragraph_id}: ${totalWords} words`);
                
                // If this paragraph has enough words, use it as-is
                if (totalWords >= MIN_WORDS_FOR_CACHING) {
                    console.log(`Paragraph has sufficient words (${totalWords} >= ${MIN_WORDS_FOR_CACHING}), using single paragraph`);
                } else {
                    // Keep adding subsequent paragraphs until we reach minimum word count
                    let nextParagraphStartIndex = endIndex + 1;
                    
                    while (nextParagraphStartIndex < wordMap.length && totalWords < MIN_WORDS_FOR_CACHING) {
                        const nextParagraphEndIndex = getEndOfParagraph(nextParagraphStartIndex);
                        const nextParagraphWords = nextParagraphEndIndex - nextParagraphStartIndex + 1;
                        
                        // Check if adding this paragraph would exceed safety limits
                        const potentialTotalWords = totalWords + nextParagraphWords;
                        const potentialText = wordMap.slice(startIndex, nextParagraphEndIndex + 1).map(w => w.text).join(' ');
                        
                        if (potentialTotalWords > maxWordsPerChunk || potentialText.length > maxCharacters) {
                            console.log(`Adding paragraph would exceed limits (${potentialTotalWords} words, ${potentialText.length} chars), stopping at ${paragraphsIncluded} paragraphs`);
                            break;
                        }
                        
                        // Add this paragraph
                        endIndex = nextParagraphEndIndex;
                        totalWords = potentialTotalWords;
                        paragraphsIncluded++;
                        
                        console.log(`Added paragraph ${paragraphsIncluded}: total ${totalWords} words`);
                        
                        // Move to next paragraph
                        nextParagraphStartIndex = endIndex + 1;
                    }
                    
                    console.log(`Optimized chunk: ${paragraphsIncluded} paragraphs, ${totalWords} words (target: ${MIN_WORDS_FOR_CACHING}+)`);
                }
            } else {
                // Fallback to sentence-based chunking if no paragraph data
                console.log('No paragraph data available, falling back to sentence-based chunking');
                endIndex = getSentenceBasedEnd(startIndex);
                totalWords = endIndex - startIndex + 1;
            }
            
            // Apply final safety limits
            const wordsInChunk = wordMap.slice(startIndex, endIndex + 1);
            const text = wordsInChunk.map(w => w.text).join(' ');
            
            if (text.length > maxCharacters || wordsInChunk.length > maxWordsPerChunk) {
                console.log(`Final chunk too large (${text.length} chars, ${wordsInChunk.length} words), applying safety limits`);
                endIndex = applySafetyLimits(startIndex, maxCharacters, maxWordsPerChunk);
            }
            
            const finalWordsInChunk = wordMap.slice(startIndex, endIndex + 1);
            const finalText = finalWordsInChunk.map(w => w.text).join(' ');
            
            console.log(`Generated optimized preload chunk from ${startIndex} to ${endIndex}: "${finalText.substring(0, 100)}..." (${finalText.length} characters, ${finalWordsInChunk.length} words, ${paragraphsIncluded} paragraphs)`);
            
            return {
                startIndex: startIndex,
                endIndex: endIndex,
                text: finalText,
                id: `chunk-${startIndex}`,
                paragraphId: startWord.paragraph_id || 'N/A',
                paragraphsIncluded: paragraphsIncluded,
                isOptimizedPreload: true
            };
        }
        
        async function seek(seconds) {
            console.log('=== SEEK CALLED ===');
            console.log(`Seek amount: ${seconds}s`);
            
            if (!gaplessPlayer || !currentChunk) {
                console.log('ERROR: No gapless player or current chunk');
                return;
            }
            
            const audioEl = $('audio-player-element');
            const currentTime = audioEl.currentTime;
            const duration = audioEl.duration;
            const newTime = currentTime + seconds;
            
            console.log(`Current chunk: startIndex=${currentChunk.startIndex}, endIndex=${currentChunk.endIndex}`);
            console.log(`Current audio: currentTime=${currentTime}s, duration=${duration}s`);
            console.log(`Calculated newTime: ${newTime}s`);
            
            if (newTime < 0) {
                console.log('>>> SEEKING BACKWARDS TO PREVIOUS CHUNK <<<');
                const overshoot = Math.abs(newTime);
                
                // Find the previous paragraph's FIRST word
                let prevWordIndex = currentChunk.startIndex - 1;
                
                if (prevWordIndex < 0) {
                    console.log('Already at first chunk, seeking to start');
                    audioEl.currentTime = 0;
                    return;
                }
                
                // Find the FIRST word of the paragraph that contains prevWordIndex
                // This is critical because getChunkForWord() creates overlapping chunks
                // (it starts from the given word and goes to end of paragraph)
                const prevChunkStartIndex = getStartOfParagraph(prevWordIndex);
                
                // Get the full chunk for logging purposes
                const prevChunk = getChunkForWord(prevChunkStartIndex);
                
                console.log(`Overshoot: ${overshoot}s, prevChunkStartIndex: ${prevChunkStartIndex}`);
                console.log(`Current chunk: ${currentChunk.startIndex}-${currentChunk.endIndex}, Previous chunk: ${prevChunk.startIndex}-${prevChunk.endIndex}`);
                console.log(`âœ“ Found ACTUAL paragraph start at word ${prevChunkStartIndex}`);
                
                await seekToPreviousChunk(prevChunkStartIndex, overshoot);
            } else if (newTime >= audioEl.duration) {
                console.log('>>> SEEKING FORWARDS TO NEXT CHUNK <<<');
                const overshoot = newTime - audioEl.duration;
                const nextChunkIndex = currentChunk.endIndex + 1;
                console.log(`Overshoot: ${overshoot}s, nextChunkIndex: ${nextChunkIndex}`);
                
                if (nextChunkIndex < wordMap.length) {
                    await seekToNextChunk(nextChunkIndex, overshoot);
                } else {
                    console.log('Already at last chunk, seeking to end');
                    audioEl.currentTime = audioEl.duration;
                }
            } else {
                console.log('>>> SEEKING WITHIN CURRENT CHUNK <<<');
                console.log(`Setting currentTime from ${currentTime}s to ${newTime}s`);
                audioEl.currentTime = newTime;
            }
            
            console.log('=== SEEK COMPLETED ===');
        }
        
        async function seekToPreviousChunk(prevChunkIndex, overshoot) {
            console.log('--- seekToPreviousChunk START ---');
            console.log(`prevChunkIndex: ${prevChunkIndex}, overshoot: ${overshoot}s`);
            
            const prevChunk = getChunkForWord(prevChunkIndex);
            if (!prevChunk) {
                console.log('ERROR: Could not get previous chunk');
                return;
            }
            
            console.log(`Previous chunk: id=${prevChunk.id}, startIndex=${prevChunk.startIndex}, endIndex=${prevChunk.endIndex}`);
            console.log(`Previous chunk text (first 50 chars): "${prevChunk.text.substring(0, 50)}..."`);
            
            const wasPlaying = isPlaying && !isPaused;
            console.log(`Was playing: ${wasPlaying}, isPlaying: ${isPlaying}, isPaused: ${isPaused}`);
            
            // Check if chunk is cached
            const cacheKey = `${prevChunk.id}-${selectedModel}`;
            const isCached = audioCache.has(cacheKey);
            console.log(`Chunk cached: ${isCached} (cache key: ${cacheKey})`);
            
            // Load the previous chunk to get its audio
            console.log('Loading previous chunk audio...');
            const audioUrl = await loadChunk(prevChunk, false); // Don't show loading indicator for cached chunks
            console.log(`Audio URL loaded: ${audioUrl.substring(0, 50)}...`);
            
            // Update current chunk
            const oldChunk = currentChunk;
            currentChunk = prevChunk;
            console.log(`Updated currentChunk from ${oldChunk.id} to ${currentChunk.id}`);
            
            updateHighlighting();
            scrollToWord(currentChunk.startIndex);
            
            const audioEl = $('audio-player-element');
            console.log(`Audio element before changes: paused=${audioEl.paused}, src=${audioEl.src.substring(0, 50)}...`);
            
            // Stop current playback
            if (!audioEl.paused) {
                console.log('Pausing current playback...');
                audioEl.pause();
            }
            
            // Set the new audio source
            console.log('Setting new audio source and playback rate...');
            audioEl.src = audioUrl;
            audioEl.playbackRate = currentPlaybackRate;
            console.log(`Audio element readyState before load(): ${audioEl.readyState}`);
            
            // Wait for metadata to load
            await new Promise((resolve, reject) => {
                const performSeek = async () => {
                    // Re-apply playback rate after load() (which may have reset it)
                    audioEl.playbackRate = currentPlaybackRate;
                    
                    const targetTime = Math.max(0, audioEl.duration - overshoot);
                    console.log(`>>> PERFORM SEEK: duration=${audioEl.duration}s, overshoot=${overshoot}s, targetTime=${targetTime}s`);
                    console.log(`Setting currentTime to ${targetTime}s...`);
                    audioEl.currentTime = targetTime;
                    console.log(`currentTime set to: ${audioEl.currentTime}s`);
                    
                    if (wasPlaying) {
                        console.log('Resuming playback...');
                        try {
                            await audioEl.play();
                            console.log('Playback resumed successfully');
                            isPlaying = true;
                            isPaused = false;
                            updatePlayPauseButtons('pause');
                        } catch (e) {
                            console.error('ERROR playing audio:', e);
                            reject(e);
                            return;
                        }
                    } else {
                        console.log('Keeping paused state');
                        isPaused = true;
                        isPlaying = false;
                        updatePlayPauseButtons('play');
                    }
                    
                    // Preload surrounding chunks
                    console.log('Preloading surrounding chunks...');
                    const nextChunkStartIndex = prevChunk.endIndex + 1;
                    if (nextChunkStartIndex < wordMap.length) {
                        preloadNextChunk(nextChunkStartIndex);
                    }
                    const prevPrevChunkIndex = prevChunk.startIndex - 1;
                    if (prevPrevChunkIndex >= 0) {
                        preloadPreviousChunks(prevPrevChunkIndex);
                    }
                    
                    console.log('--- seekToPreviousChunk COMPLETE ---');
                    resolve();
                };
                
                const onLoadedMetadata = () => {
                    console.log(`loadedmetadata event fired! readyState: ${audioEl.readyState}, duration: ${audioEl.duration}s`);
                    audioEl.removeEventListener('error', onError);
                    performSeek();
                };
                
                const onError = (e) => {
                    console.error('ERROR event fired while loading audio:', e);
                    audioEl.removeEventListener('loadedmetadata', onLoadedMetadata);
                    reject(new Error('Failed to load previous chunk audio'));
                };
                
                console.log('Adding event listeners for loadedmetadata and error...');
                audioEl.addEventListener('loadedmetadata', onLoadedMetadata, { once: true });
                audioEl.addEventListener('error', onError, { once: true });
                
                // Force loading metadata if the audio is cached
                console.log('Calling audioEl.load()...');
                audioEl.load();
                console.log(`Audio element readyState after load(): ${audioEl.readyState}`);
            });
        }
        
        async function seekToNextChunk(nextChunkIndex, overshoot) {
            const nextChunk = getChunkForWord(nextChunkIndex);
            if (!nextChunk) return;
            
            const wasPlaying = isPlaying && !isPaused;
            
            // Load the next chunk
            const audioUrl = await loadChunk(nextChunk, false); // Don't show loading indicator for cached chunks
            
            // Update current chunk
            currentChunk = nextChunk;
            updateHighlighting();
            scrollToWord(currentChunk.startIndex);
            
            const audioEl = $('audio-player-element');
            
            // Stop current playback
            if (!audioEl.paused) {
                audioEl.pause();
            }
            
            // Set the new audio source
            audioEl.src = audioUrl;
            audioEl.playbackRate = currentPlaybackRate;
            
            // Wait for metadata to load
            await new Promise((resolve, reject) => {
                const performSeek = async () => {
                    // Re-apply playback rate after load() (which may have reset it)
                    audioEl.playbackRate = currentPlaybackRate;
                    
                    const targetTime = Math.min(overshoot, audioEl.duration);
                    console.log(`Seeking to next chunk: duration=${audioEl.duration}s, overshoot=${overshoot}s, targetTime=${targetTime}s`);
                    audioEl.currentTime = targetTime;
                    
                    if (wasPlaying) {
                        try {
                            await audioEl.play();
                            isPlaying = true;
                            isPaused = false;
                            updatePlayPauseButtons('pause');
                        } catch (e) {
                            console.error('Error playing audio:', e);
                            reject(e);
                            return;
                        }
                    } else {
                        isPaused = true;
                        isPlaying = false;
                        updatePlayPauseButtons('play');
                    }
                    
                    // Preload surrounding chunks
                    const subsequentChunkIndex = nextChunk.endIndex + 1;
                    if (subsequentChunkIndex < wordMap.length) {
                        preloadNextChunk(subsequentChunkIndex);
                    }
                    const prevChunkIndex = nextChunk.startIndex - 1;
                    if (prevChunkIndex >= 0) {
                        preloadPreviousChunks(prevChunkIndex);
                    }
                    
                    resolve();
                };
                
                const onLoadedMetadata = () => {
                    audioEl.removeEventListener('error', onError);
                    performSeek();
                };
                
                const onError = () => {
                    audioEl.removeEventListener('loadedmetadata', onLoadedMetadata);
                    reject(new Error('Failed to load next chunk audio'));
                };
                
                audioEl.addEventListener('loadedmetadata', onLoadedMetadata, { once: true });
                audioEl.addEventListener('error', onError, { once: true });
                
                // Force loading metadata if the audio is cached
                audioEl.load();
            });
        }

        // --- UI & STATE MANAGEMENT --- //
        function updateHighlighting() {
            document.querySelectorAll('.text-span.word-playing-chunk').forEach(s => s.classList.remove('word-playing-chunk'));
            
            if (!currentChunk || (!isPlaying && !isPaused)) {
                updateGoToCurrentButton();
                return;
            }

            for (let i = currentChunk.startIndex; i <= currentChunk.endIndex; i++) {
                const span = document.querySelector(`.text-span[data-word-index="${i}"]`);
                if (span) span.classList.add('word-playing-chunk');
            }
            
            // Update the go to current button based on browsing state
            updateGoToCurrentButton();
        }

        async function handleVoiceChange(newVoice) {
            selectedModel = newVoice;
            saveUserPreferences();
            applyPreferencesToUI();
            
            if (isPlaying || isPaused) {
                const savedIndex = currentChunk.startIndex;
                const wasPlaying = isPlaying;
                await stopPlayback();
                if(wasPlaying) {
                    await playFromWord(savedIndex);
                }
            }
        }

        let skipPatternsChangeTimeout = null;
        
        async function handleSkipPatternsChange(newSkipPatterns) {
            // Debounce rapid changes
            if (skipPatternsChangeTimeout) {
                clearTimeout(skipPatternsChangeTimeout);
            }
            
            const oldSkipPatterns = skipPatterns;
            skipPatterns = newSkipPatterns;
            saveUserPreferences();
            applyPreferencesToUI();
            
            // If we have a current file loaded and the setting changed, reload the words
            if (currentFileId && oldSkipPatterns !== newSkipPatterns) {
                skipPatternsChangeTimeout = setTimeout(async () => {
                    await reloadCurrentPDFWithNewSettings();
                    skipPatternsChangeTimeout = null;
                }, 300); // 300ms debounce
            }
        }

        let isReloadingSettings = false;
        
        async function reloadCurrentPDFWithNewSettings() {
            if (isReloadingSettings) {
                console.log('Already reloading settings, skipping duplicate request');
                return;
            }
            
            isReloadingSettings = true;
            showLoading('Applying pattern filtering...');
            
            try {
                // Fetch words with new pattern filtering setting
                const url = new URL(`/api/user/pdfs/${currentFileId}/words`, window.location.origin);
                url.searchParams.set('skip_patterns', skipPatterns.toString());
                
                const response = await makeAuthenticatedRequest(url);
                if (!response.ok) {
                    throw new Error('Failed to reload PDF words');
                }
                
                const data = await response.json();
                if (data.cached && data.words) {
                    const oldWordIndex = currentChunk ? currentChunk.startIndex : 0;
                    
                    // Update word map
                    wordMap = data.words;
                    
                    // Clear audio cache since word indices might have changed
                    audioCache.clear();
                    
                    // Show feedback about filtering
                    if (data.patterns_filtered > 0) {
                        showSuccessMessage(`Filtered ${data.patterns_filtered} repeated words (headers/footers/page numbers)`);
                    }
                    
                    // Try to maintain playback position if we were playing
                    if (isPlaying || isPaused) {
                        // Find the closest word position in the new filtered text
                        const newPosition = Math.min(oldWordIndex, wordMap.length - 1);
                        await stopPlayback();
                        setTimeout(() => {
                            playFromWord(newPosition);
                        }, 100);
                    }
                    
                    // Re-render the PDF to update word mappings
                    await rerenderVisiblePages();
                }
            } catch (error) {
                console.error('Error reloading PDF with new settings:', error);
                showError('Failed to apply pattern filtering setting');
            } finally {
                hideLoading();
                isReloadingSettings = false;
            }
        }

        function changePlaybackRate(newRate) {
            currentPlaybackRate = parseFloat(newRate);
            saveUserPreferences();
            applyPreferencesToUI();
            if (gaplessPlayer) {
                gaplessPlayer.changeSpeed(currentPlaybackRate);
            }
        }

        function cyclePlaybackSpeed() {
            const speeds = [0.75, 1.0, 1.25, 1.5, 2.0];
            const currentIndex = speeds.indexOf(currentPlaybackRate);
            const nextIndex = (currentIndex + 1) % speeds.length;
            changePlaybackRate(speeds[nextIndex]);
        }
        
        async function resetToUpload() {
            showUploadLoading('Exiting...');
            try {
                // Save progress before exiting PDF (only if audio was played)
                if (currentFileId && wordMap.length > 0 && currentChunk) {
                    await saveReadingProgress();
                }
                stopProgressTracking();
                
                closePlayer();
                $('pdf-display').classList.add('hidden');
                $('upload-container').classList.remove('hidden');
                document.body.classList.remove('reading');
                $('app-container').style.paddingBottom = '0px';
                resetPdfState();
                $('pdf-input').value = '';
                
                // Reload the PDF library to show updated progress
                await loadUserPDFs();
                
                // Clear current file ID and saved progress when exiting
                currentFileId = null;
                savedProgress = null;
            } finally {
                hideUploadLoading();
            }
        }
        
        function resetPdfState() {
            pdfDoc = null; wordMap = []; audioCache.clear(); currentChunk = null;
            if ($('pdf-viewer')) $('pdf-viewer').innerHTML = '';
        }

        async function loadUserPreferences() {
            try {
                // First check if we have localStorage preferences to migrate
                const localPrefs = localStorage.getItem('sonic-reader-prefs');
                if (localPrefs) {
                    console.log("Found localStorage preferences, migrating to database...");
                    try {
                        const response = await fetch('/api/user/preferences/migrate', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'Authorization': `Bearer ${localStorage.getItem('auth_token')}`
                            },
                            body: JSON.stringify({
                                localStorage_prefs: JSON.parse(localPrefs)
                            })
                        });
                        
                        if (response.ok) {
                            console.log("Successfully migrated preferences to database");
                            localStorage.removeItem('sonic-reader-prefs');
                        }
                    } catch (migrationError) {
                        console.error("Failed to migrate preferences:", migrationError);
                    }
                }
                
                // Load preferences from database
                const response = await fetch('/api/user/preferences', {
                    headers: {
                        'Authorization': `Bearer ${localStorage.getItem('auth_token')}`
                    }
                });
                
                if (response.ok) {
                    const data = await response.json();
                    if (data.success && data.preferences) {
                        selectedModel = data.preferences.voice_model || 'edge-tts-andrew';
                        currentPlaybackRate = data.preferences.voice_speed || 1.0;
                        skipPatterns = data.preferences.skip_patterns || false;
                        console.log("Loaded user preferences from database:", data.preferences);
                    } else {
                        setDefaultPreferences();
                    }
                } else {
                    console.error("Failed to load preferences from database");
                    setDefaultPreferences();
                }
            } catch (e) { 
                console.error("Could not load user preferences", e); 
                setDefaultPreferences();
            }
        }

        function setDefaultPreferences() {
            selectedModel = 'edge-tts-andrew';
            currentPlaybackRate = 1.0;
            skipPatterns = false;
        }

        async function saveUserPreferences() { 
            try {
                if (currentFileId) {
                    // Save as book-specific preferences if a PDF is open
                    await saveBookPreferences();
                } else {
                    // Save as user default preferences
                    const response = await fetch('/api/user/preferences', {
                        method: 'PUT',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${localStorage.getItem('auth_token')}`
                        },
                        body: JSON.stringify({
                            voice_model: selectedModel,
                            voice_speed: currentPlaybackRate,
                            skip_patterns: skipPatterns
                        })
                    });
                    
                    if (response.ok) {
                        console.log("User preferences saved to database");
                    } else {
                        console.error("Failed to save preferences to database");
                    }
                }
            } catch (e) {
                console.error("Error saving preferences:", e);
            }
        }

        async function saveBookPreferences() {
            if (!currentFileId) return;
            
            try {
                const preferences = {
                    voice_model: selectedModel,
                    voice_speed: currentPlaybackRate,
                    skip_patterns: skipPatterns,
                    background_music_enabled: backgroundMusicEnabled,
                    background_music_file_id: currentBackgroundMusic,
                    background_music_volume: backgroundMusicVolume
                };

                const response = await fetch(`/api/user/preferences/book/${currentFileId}`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${localStorage.getItem('auth_token')}`
                    },
                    body: JSON.stringify(preferences)
                });
                
                if (response.ok) {
                    console.log("Book preferences saved to database");
                } else {
                    console.error("Failed to save book preferences to database");
                }
            } catch (e) {
                console.error("Error saving book preferences:", e);
            }
        }

        function applyPreferencesToUI() {
            $('sticky-voice-select').value = selectedModel;
            $('mobile-voice-select').value = selectedModel;
            
            let speedValue = String(currentPlaybackRate);
            // If the number is an integer (e.g., 1, 2), format it with one decimal place.
            if (currentPlaybackRate % 1 === 0) {
                speedValue = currentPlaybackRate.toFixed(1);
            }
            $('sticky-speed-select').value = speedValue;
            $('mobile-speed-select').value = speedValue;
            
            // Apply skip patterns preference
            $('sticky-skip-patterns').checked = skipPatterns;
            $('mobile-skip-patterns').checked = skipPatterns;
            
            // Apply preferences to default preferences UI on homepage
            applyPreferencesToDefaultUI();
        }



        function showUploadLoading(show, text = '') {
            $('upload-loading').classList.toggle('hidden', !show);
            if (show) $('upload-loading-text').textContent = text;
            $('upload-area').style.pointerEvents = show ? 'none' : 'auto';
        }

        function showLoading(text) { 
            $('loading-indicator').classList.remove('hidden'); 
            $('loading-text').textContent = text; 
        }
        function hideLoading() { 
            $('loading-indicator').classList.add('hidden'); 
        }
        function showError(msg) { 
            const errorSection = $('error-section');
            errorSection.classList.remove('hidden'); 
            $('error-message').textContent = msg; 
            setTimeout(() => {
                errorSection.classList.add('hidden');
            }, 5000);
        }
        
        function updatePlayPauseButtons(state) { // state is 'play' or 'pause'
            const iconClass = state === 'pause' ? 'pause' : 'play';
            $('sticky-play-pause-btn').innerHTML = `<i data-lucide="${iconClass}" class="h-6 w-6"></i>`;
            $('mobile-play-pause-btn').innerHTML = `<i data-lucide="${iconClass}" class="h-8 w-8"></i>`;
            lucide.createIcons();
        }
        
        function showPlayer() {
            const player = $('sticky-audio-player');
            player.classList.remove('translate-y-full');
            document.body.classList.add('reading');
            const playerHeight = player.offsetHeight;
            $('app-container').style.paddingBottom = `${playerHeight}px`;
        }

        function hidePlayer() {
            const player = $('sticky-audio-player');
            player.classList.add('translate-y-full');
            document.body.classList.remove('reading');
            $('app-container').style.paddingBottom = '0px';
        }

        // --- WEB AUDIO PLAYER (HTML5 Audio Element based) --- //
        function initializeWebAudioPlayer() {
            const audioEl = $('audio-player-element');
            
            // Clear all existing event listeners to prevent conflicts
            audioEl.onplaying = null;
            audioEl.onerror = null;
            audioEl.onended = null;
            audioEl.onpause = null;
            
            gaplessPlayer = {
                play: (url, chunkId) => {
                    return new Promise((resolve, reject) => {
                        // Stop any existing playback first
                        if (!audioEl.paused) {
                            audioEl.pause();
                        }
                        
                        // Clear event listeners
                        audioEl.onplaying = null;
                        audioEl.onerror = null;
                        
                        // Set source and playback rate
                        audioEl.src = url;
                        audioEl.playbackRate = currentPlaybackRate;
                        
                        // Create a one-time playing event handler
                        const onPlayingHandler = () => {
                            audioEl.removeEventListener('playing', onPlayingHandler);
                            audioEl.removeEventListener('error', onErrorHandler);
                            resolve();
                        };
                        
                        const onErrorHandler = (e) => {
                            audioEl.removeEventListener('playing', onPlayingHandler);
                            audioEl.removeEventListener('error', onErrorHandler);
                            reject(new Error("Audio playback error: " + e.message));
                        };
                        
                        // Add event listeners
                        audioEl.addEventListener('playing', onPlayingHandler, { once: true });
                        audioEl.addEventListener('error', onErrorHandler, { once: true });
                        
                        // Start playback with user gesture check
                        const playPromise = audioEl.play();
                        if (playPromise !== undefined) {
                            playPromise.catch(e => {
                                audioEl.removeEventListener('playing', onPlayingHandler);
                                audioEl.removeEventListener('error', onErrorHandler);
                                console.error("Play promise failed:", e);
                                
                                // Check if it's an autoplay policy issue
                                if (e.name === 'NotAllowedError') {
                                    reject(new Error("Autoplay is not allowed. Please interact with the page first."));
                                } else {
                                    reject(e);
                                }
                            });
                        }
                    });
                },
                pause: () => { 
                    if (!audioEl.paused) {
                        audioEl.pause();
                    }
                },
                resume: () => { 
                    return audioEl.play().catch(e => {
                        console.error("Resume failed:", e);
                        if (e.name === 'NotAllowedError') {
                            throw new Error("Autoplay is not allowed. Please interact with the page first.");
                        }
                        throw e;
                    });
                },
                stop: () => { 
                    if (!audioEl.paused) {
                        audioEl.pause();
                    }
                    audioEl.removeAttribute('src');
                    audioEl.load();
                },
                changeSpeed: (newRate) => {
                    currentPlaybackRate = newRate;
                    audioEl.playbackRate = newRate;
                    saveUserPreferences();
                }
            };

            // Set up the ended event listener only once
            audioEl.addEventListener('ended', () => {
                if (isPlaying && !isPaused) {
                    playNextChunk();
                }
            }, { once: false });
        }

        // --- READING PROGRESS FUNCTIONS --- //
        function updateReadingProgressDisplay() {
            if (!wordMap.length) return;
            
            let progressPercentage = 0;
            
            if (currentChunk) {
                // Calculate progress based on current audio chunk position
                const currentWordIndex = currentChunk.startIndex;
                progressPercentage = Math.round((currentWordIndex / wordMap.length) * 100);
            }
            // If no currentChunk, progress stays at 0% or shows last saved progress
            
            // Update header progress bar
            const progressBar = $('reading-progress-bar');
            const progressText = $('reading-progress-text');
            
            if (progressBar && progressText) {
                progressBar.style.width = `${progressPercentage}%`;
                progressText.textContent = `${progressPercentage}%`;
            }
        }
        
        function updateHeaderButtonForResume(hasProgress = false) {
            const startButton = $('pdf-start-reading');
            console.log('updateHeaderButtonForResume called with hasProgress:', hasProgress, 'savedProgress:', savedProgress);
            if (startButton && hasProgress) {
                startButton.innerHTML = `
                    <i data-lucide="play-circle" class="h-5 w-5"></i>
                    <span class="hidden md:inline">Resume</span>
                `;
                // Remove all existing event listeners by cloning the button
                const buttonContainer = startButton.parentElement;
                const newButton = startButton.cloneNode(true);
                startButton.parentNode.replaceChild(newButton, startButton);
                // Set the new event handler
                newButton.onclick = () => resumeFromSavedPosition();
                
                // Add start over button next to it
                if (!$('pdf-start-over')) {
                    const startOverButton = document.createElement('button');
                    startOverButton.id = 'pdf-start-over';
                    startOverButton.className = 'inline-flex items-center justify-center whitespace-nowrap rounded-lg text-sm font-medium transition-colors outline-offset-2 focus-visible:outline focus-visible:outline-2 focus-visible:outline-ring/70 disabled:pointer-events-none disabled:opacity-50 border border-slate-600 bg-slate-800 shadow-sm shadow-black/5 hover:bg-slate-700 hover:text-slate-200 text-slate-300 h-9 px-4 py-2 gap-2';
                    startOverButton.innerHTML = `
                        <i data-lucide="rotate-ccw" class="h-5 w-5"></i>
                        <span class="hidden md:inline">Start Over</span>
                    `;
                    startOverButton.onclick = () => playFromWord(0);
                    buttonContainer.insertBefore(startOverButton, newButton.nextSibling);
                    
                    // Reinitialize icons
                    lucide.createIcons();
                }
            }
        }
        
        function updateHeaderButtonForStart() {
            const startButton = $('pdf-start-reading');
            if (startButton) {
                startButton.innerHTML = `
                    <i data-lucide="play-circle" class="h-5 w-5"></i>
                    <span class="hidden md:inline">Start Reading</span>
                `;
                // Remove all existing event listeners by cloning the button
                const newButton = startButton.cloneNode(true);
                startButton.parentNode.replaceChild(newButton, startButton);
                // Set the new event handler
                newButton.onclick = () => playFromWord(0);
                
                // Remove start over button if it exists
                const startOverButton = $('pdf-start-over');
                if (startOverButton) {
                    startOverButton.remove();
                }
                
                // Reinitialize icons
                lucide.createIcons();
            }
        }
        
        let savedProgress = null; // Store saved progress globally
        
        async function loadBookPreferences(fileId) {
            try {
                console.log('Loading book preferences for fileId:', fileId);
                const response = await makeAuthenticatedRequest(`/api/user/preferences/effective/${fileId}`);
                if (response.ok) {
                    const data = await response.json();
                    if (data.success && data.preferences) {
                        console.log('Book preferences loaded:', data.preferences);
                        
                        // Apply book preferences
                        selectedModel = data.preferences.voice_model || 'edge-tts-andrew';
                        currentPlaybackRate = data.preferences.voice_speed || 1.0;
                        skipPatterns = data.preferences.skip_patterns || false;
                        
                        // Apply background music preferences
                        if (data.preferences.background_music_enabled && data.preferences.background_music_file_id) {
                            backgroundMusicEnabled = true;
                            currentBackgroundMusic = data.preferences.background_music_file_id;
                            backgroundMusicVolume = data.preferences.background_music_volume || 0.10;
                            
                            // Update UI
                            $('background-music-toggle').checked = true;
                            $('mobile-background-music-toggle').checked = true;
                            $('background-music-select').value = currentBackgroundMusic;
                            $('mobile-background-music-select').value = currentBackgroundMusic;
                            // Convert DB decimal (0.1) to slider value (0-50 range)
                            const sliderValue = Math.round(backgroundMusicVolume * 50); // 0.1 -> 5
                            setBackgroundMusicVolume(sliderValue);
                            
                            // Show the background music controls
                            toggleBackgroundMusic(true);
                            
                            // Preload the background music for instant playback
                            if (currentBackgroundMusic) {
                                preloadBackgroundMusic(currentBackgroundMusic);
                            }
                        } else {
                            backgroundMusicEnabled = false;
                            currentBackgroundMusic = null;
                            $('background-music-toggle').checked = false;
                            $('mobile-background-music-toggle').checked = false;
                            $('background-music-select').value = '';
                            $('mobile-background-music-select').value = '';
                            
                            // Hide the background music controls
                            toggleBackgroundMusic(false);
                        }
                        
                        // Update UI to reflect preferences
                        applyPreferencesToUI();
                        
                        // Show indicator if book has custom preferences
                        if (data.preferences.has_book_overrides) {
                            console.log('Book has custom preferences');
                            // Could add a visual indicator here
                        }
                    }
                } else {
                    console.error('Failed to load book preferences');
                }
            } catch (error) {
                console.error('Error loading book preferences:', error);
            }
        }

        async function loadReadingProgress(fileId) {
            try {
                currentFileId = fileId;
                console.log('loadReadingProgress called for fileId:', fileId);
                
                // Load book preferences first
                await loadBookPreferences(fileId);
                
                const response = await makeAuthenticatedRequest(`/api/reading-progress?pdf_id=${fileId}`);
                if (response.ok) {
                    const data = await response.json();
                    console.log('Progress data received:', data);
                    if (data.progress && data.progress.current_word_index > 0) {
                        savedProgress = data.progress; // Store saved progress
                        console.log('Saved progress set to:', savedProgress);
                        
                        // Update header to show resume button
                        updateHeaderButtonForResume(true);
                        
                        // Show saved progress in header
                        displaySavedProgress();
                        
                        // Auto-scroll to saved position
                        const savedWordIndex = data.progress.current_word_index;
                        console.log(`Will scroll to word index: ${savedWordIndex}`);
                        
                        setTimeout(() => {
                            scrollToWordByIndex(savedWordIndex);
                        }, 1000);
                    } else {
                        console.log('No progress found or progress is 0');
                        savedProgress = null;
                        updateHeaderButtonForStart();
                        displaySavedProgress(); // Show 0% progress
                    }
                } else {
                    console.log('Failed to load progress, response not ok');
                    savedProgress = null;
                    updateHeaderButtonForStart();
                    displaySavedProgress(); // Show 0% progress
                }
            } catch (error) {
                console.error('Error loading reading progress:', error);
                savedProgress = null;
                updateHeaderButtonForStart();
                displaySavedProgress(); // Show 0% progress
            }
        }
        
        function displaySavedProgress() {
            const progressBar = $('reading-progress-bar');
            const progressText = $('reading-progress-text');
            
            if (progressBar && progressText) {
                if (savedProgress && savedProgress.total_words > 0) {
                    const progressPercentage = Math.round((savedProgress.current_word_index / savedProgress.total_words) * 100);
                    progressBar.style.width = `${progressPercentage}%`;
                    progressText.textContent = `${progressPercentage}%`;
                } else {
                    progressBar.style.width = '0%';
                    progressText.textContent = '0%';
                }
            }
        }
        
        function resumeFromSavedPosition() {
            console.log('resumeFromSavedPosition called, savedProgress:', savedProgress);
            if (savedProgress && savedProgress.current_word_index > 0) {
                console.log(`Attempting to resume from word index: ${savedProgress.current_word_index}`);
                playFromWord(savedProgress.current_word_index);
            } else {
                console.log('No saved progress found, starting from beginning');
                playFromWord(0);
            }
        }
        
        async function saveReadingProgress() {
            if (!currentFileId || !wordMap.length || !currentChunk) return;
            
            try {
                // Use current audio chunk position for progress
                const currentWordIndex = currentChunk.startIndex;
                const progressPercentage = Math.round((currentWordIndex / wordMap.length) * 100);
                
                // Get current page from word data
                const currentWordData = wordMap[currentWordIndex];
                const currentPage = currentWordData ? currentWordData.page : 1;
                
                const response = await makeAuthenticatedRequest('/api/reading-progress', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        pdf_id: currentFileId,
                        current_word_index: currentWordIndex,
                        total_words: wordMap.length,
                        progress_percentage: progressPercentage,
                        current_page: currentPage
                    })
                });
                
                if (response.ok) {
                    console.log(`Progress saved: ${progressPercentage}% (word ${currentWordIndex}/${wordMap.length}) on page ${currentPage}`);
                    // Update the progress display
                    updateReadingProgressDisplay();
                } else {
                    console.error('Failed to save reading progress');
                }
            } catch (error) {
                console.error('Error saving reading progress:', error);
            }
        }

        // --- USER PDF LIBRARY FUNCTIONS --- //
        async function loadUserPDFs() {
            try {
                const response = await makeAuthenticatedRequest('/api/user/pdfs');
                if (!response.ok) {
                    throw new Error('Failed to load user PDFs');
                }
                
                const data = await response.json();
                await displayUserPDFs(data.pdfs || []);
            } catch (error) {
                console.error('Error loading user PDFs:', error);
                $('user-pdfs-loading').classList.add('hidden');
                $('user-pdfs-empty').classList.remove('hidden');
            }
        }
        
        async function displayUserPDFs(pdfs) {
            $('user-pdfs-loading').classList.add('hidden');
            
            // Always hide the list first to ensure proper state management
            $('user-pdfs-list').classList.add('hidden');
            $('user-pdfs-empty').classList.add('hidden');
            
            // Update PDF count
            const countElement = $('pdf-count');
            const count = pdfs.length;
            countElement.textContent = `${count} document${count !== 1 ? 's' : ''}`;
            
            if (pdfs.length === 0) {
                $('user-pdfs-empty').classList.remove('hidden');
                console.log('No PDFs to display - showing empty state');
                return;
            }
            
            const grid = $('pdfs-grid');
            // Force clear the grid
            grid.innerHTML = '';
            
            console.log(`Displaying ${pdfs.length} PDFs`);
            
            // Show loading placeholder for cards
            grid.innerHTML = '<div class="col-span-full text-center text-slate-400">Loading progress data...</div>';
            
            // Create all PDF cards asynchronously
            const cardPromises = pdfs.map(async (pdf, index) => {
                console.log(`Creating card for PDF ${index + 1}: ${pdf.filename}`);
                return await createPDFCard(pdf);
            });
            
            // Wait for all cards to be created
            const pdfCards = await Promise.all(cardPromises);
            
            // Clear loading and add all cards
            grid.innerHTML = '';
            pdfCards.forEach(card => {
                grid.appendChild(card);
            });
            
            $('user-pdfs-list').classList.remove('hidden');
            
            // Reinitialize Lucide icons after DOM updates
            setTimeout(() => {
                lucide.createIcons();
                console.log('Lucide icons reinitialized');
            }, 50);
        }
        
        async function createPDFCard(pdf) {
            const card = document.createElement('div');
            card.className = 'pdf-item group relative overflow-hidden bg-slate-900/60 backdrop-blur-sm border border-slate-700/50 rounded-2xl p-4 hover:border-blue-500/50 hover:bg-slate-800/70 transition-all duration-300 cursor-pointer';
            
            const createdDate = new Date(pdf.created_at).toLocaleDateString();
            const fileSize = formatFileSize(pdf.file_size || 0);
            
            // Truncate filename if too long (very conservative to prevent overlapping)
            const truncatedFilename = truncateFilename(pdf.filename, 15);
            
            // Get reading progress for this PDF
            let progressPercentage = 0;
            try {
                const progressResponse = await makeAuthenticatedRequest(`/api/reading-progress?pdf_id=${pdf.file_id}`);
                if (progressResponse.ok) {
                    const progressData = await progressResponse.json();
                    if (progressData.progress && progressData.progress.total_words > 0) {
                        progressPercentage = Math.round((progressData.progress.current_word_index / progressData.progress.total_words) * 100);
                    }
                }
            } catch (error) {
                console.log('Could not fetch progress for PDF:', pdf.filename);
            }
            
            // Generate PDF thumbnail
            let thumbnailElement = `<i data-lucide="file-text" class="h-8 w-8 text-blue-400"></i>`;
            try {
                const thumbnailDataUrl = await generatePDFThumbnail(pdf.file_id);
                if (thumbnailDataUrl) {
                    thumbnailElement = `<img src="${thumbnailDataUrl}" alt="PDF thumbnail" class="w-full h-full object-cover rounded">`;
                }
            } catch (error) {
                console.log('Could not generate thumbnail for PDF:', pdf.filename);
            }
            
            const progressColor = progressPercentage > 90 ? 'bg-green-500' : progressPercentage > 50 ? 'bg-blue-500' : 'bg-gray-500';
            const progressDisplay = progressPercentage > 0 ? `${progressPercentage}% complete` : 'Not started';
            
            card.innerHTML = `
                <!-- Gradient overlay -->
                <div class="absolute inset-0 bg-gradient-to-br from-blue-600/5 via-transparent to-purple-600/5 rounded-2xl opacity-0 group-hover:opacity-100 transition-opacity duration-300"></div>
                
                <!-- Delete Button -->
                <button class="delete-pdf-btn absolute top-3 right-3 z-10 w-7 h-7 flex items-center justify-center text-slate-500 bg-slate-800/50 rounded-full hover:bg-red-500/20 hover:text-red-400 transition-all duration-200 opacity-0 group-hover:opacity-100" 
                        data-pdf-id="${pdf.file_id}" title="Delete PDF">
                    <i data-lucide="trash-2" class="h-3.5 w-3.5"></i>
                </button>

                <!-- New Badge -->
                ${progressPercentage === 0 ? '<div class="absolute top-4 left-4 z-10"><span class="text-xs bg-gradient-to-r from-green-500 to-emerald-500 text-white px-2 py-1 rounded-full font-medium">New</span></div>' : ''}
                
                <div class="relative h-full flex flex-col text-center">
                    <!-- Thumbnail Section -->
                    <div class="mb-4">
                        <div class="relative w-24 h-32 bg-slate-800/70 rounded-lg overflow-hidden flex items-center justify-center mx-auto shadow-md">
                            ${thumbnailElement}
                            ${progressPercentage > 0 ? `
                                <div class="absolute bottom-1 right-1 px-1.5 py-0.5 bg-slate-900/70 backdrop-blur-sm rounded-md flex items-center justify-center border border-slate-700">
                                    <span class="text-xs font-bold text-blue-300">${Math.round(progressPercentage)}%</span>
                                </div>
                            ` : ''}
                        </div>
                    </div>
                    
                    <!-- Flexible Content Section -->
                    <div class="flex flex-col flex-1 justify-between">
                        <!-- Title & Progress -->
                        <div>
                            <h4 class="font-semibold text-slate-100 mb-1 leading-tight" title="${escapeHtml(pdf.filename)}">${escapeHtml(truncatedFilename)}</h4>
                            <p class="text-xs text-slate-400 mb-3">${createdDate}</p>

                            <div class="w-full bg-slate-700/50 rounded-full h-1.5 overflow-hidden" title="${progressDisplay}">
                                <div class="bg-gradient-to-r from-blue-500 to-cyan-500 h-1.5 rounded-full transition-all duration-500" 
                                     style="width: ${progressPercentage}%"></div>
                            </div>
                        </div>

                        <!-- Action Button -->
                        <div class="mt-4">
                            <button class="load-pdf-btn w-full flex items-center justify-center gap-2 bg-blue-600 hover:bg-blue-700 text-white px-3 py-2.5 rounded-lg text-sm font-semibold transition-all duration-200 shadow-lg shadow-blue-600/20 hover:shadow-blue-600/40" 
                                    data-pdf-id="${pdf.file_id}">
                                <i data-lucide="play" class="h-4 w-4"></i>
                                <span>${progressPercentage > 0 ? 'Continue Reading' : 'Start Reading'}</span>
                            </button>
                        </div>
                    </div>
                </div>
            `;
            
            // Add event listeners
            const loadBtn = card.querySelector('.load-pdf-btn');
            const deleteBtn = card.querySelector('.delete-pdf-btn');
            
            loadBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                loadExistingPDF(pdf.file_id, pdf.filename);
            });
            
            deleteBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                deletePDF(pdf.file_id, pdf.filename);
            });
            
            return card;
        }
        
        async function generatePDFThumbnail(fileId) {
            try {
                // Get the PDF file
                const response = await makeAuthenticatedRequest(`/api/user/pdfs/${fileId}`);
                if (!response.ok) return null;
                
                const pdfBlob = await response.blob();
                const arrayBuffer = await pdfBlob.arrayBuffer();
                
                // Load PDF with PDF.js
                pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
                const loadingTask = pdfjsLib.getDocument({ data: arrayBuffer });
                const pdf = await loadingTask.promise;
                
                // Get the first page
                const page = await pdf.getPage(1);
                
                // Set up canvas for thumbnail (high quality for large display)
                const viewport = page.getViewport({ scale: 1.0 });
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                
                canvas.width = viewport.width;
                canvas.height = viewport.height;
                
                // Render the page
                await page.render({
                    canvasContext: context,
                    viewport: viewport
                }).promise;
                
                // Convert to data URL
                return canvas.toDataURL('image/jpeg', 0.8);
                
            } catch (error) {
                console.error('Error generating thumbnail:', error);
                return null;
            }
        }
        
        async function loadExistingPDF(fileId, filename) {
            try {
                showUploadLoading(true, 'Loading PDF...');
                
                // Get PDF file data
                const response = await makeAuthenticatedRequest(`/api/user/pdfs/${fileId}`);
                if (!response.ok) {
                    throw new Error('Failed to load PDF file');
                }
                
                const pdfBlob = await response.blob();
                const file = new File([pdfBlob], filename, { type: 'application/pdf' });
                
                // Load the PDF without uploading it again
                await loadExistingPDFData(file, fileId);
                
            } catch (error) {
                console.error('Error loading existing PDF:', error);
                showError('Failed to load PDF: ' + error.message);
                showUploadLoading(false);
            }
        }
        
        async function loadExistingPDFData(file, fileId) {
            try {
                // First try to load cached word data with current skip patterns preference
                console.log('Checking for cached word data...');
                
                const url = new URL(`/api/user/pdfs/${fileId}/words`, window.location.origin);
                url.searchParams.set('skip_patterns', skipPatterns.toString());
                
                const cachedResponse = await makeAuthenticatedRequest(url);
                
                if (cachedResponse.ok) {
                    const cachedData = await cachedResponse.json();
                    
                    if (cachedData.cached && cachedData.words && cachedData.words.length > 0) {
                        console.log(`Using cached word data: ${cachedData.word_count} words (cached at ${cachedData.cached_at})`);
                        wordMap = cachedData.words;
                        
                        // Show feedback about pattern filtering if applied
                        if (cachedData.skip_patterns_enabled && cachedData.patterns_filtered > 0) {
                            showSuccessMessage(`Filtered ${cachedData.patterns_filtered} repeated words (headers/footers/page numbers) from ${cachedData.original_word_count} total words`);
                        }
                        
                        showUploadLoading(false);
                        await displayPDF(file);
                        
                        // Set the current file ID for progress tracking
                        currentFileId = fileId;
                        
                        // Load reading progress and resume from last position
                        await loadReadingProgress(fileId);
                        return;
                    }
                }
                
                // No cache available, extract words from the PDF file
                console.log('No cached data found, extracting words from PDF...');
                
                const formData = new FormData();
                formData.append('file', file);
                formData.append('file_id', fileId); // Include file_id for caching
                formData.append('skip_patterns', skipPatterns.toString());
                
                // Call extract-words endpoint which will cache the results
                const response = await makeAuthenticatedRequest('/api/extract-words', {
                    method: 'POST',
                    body: formData
                });
                
                if (response.ok) {
                    const data = await response.json();
                    wordMap = data.words || [];
                    
                    // Show feedback about pattern filtering if applied
                    if (data.skip_patterns_enabled && data.patterns_filtered > 0) {
                        showSuccessMessage(`Filtered ${data.patterns_filtered} repeated words (headers/footers/page numbers) from ${data.original_word_count} total words`);
                    }
                    
                    if (data.cached) {
                        console.log(`Used cached word data: ${data.word_count} words`);
                    } else {
                        console.log(`Extracted and cached word data: ${data.word_count} words`);
                    }
                } else {
                    throw new Error('Failed to extract words from PDF');
                }
                
                showUploadLoading(false);
                await displayPDF(file);
                
                // Set the current file ID for progress tracking
                currentFileId = fileId;
                
                // Load reading progress and resume from last position
                await loadReadingProgress(fileId);
                
            } catch (error) {
                console.error('Error loading existing PDF data:', error);
                showUploadLoading(false);
                showError('Failed to load PDF: ' + error.message);
            }
        }
        
        async function deletePDF(fileId, filename) {
            if (!confirm(`Are you sure you want to delete "${filename}"? This action cannot be undone.`)) {
                return;
            }
            
            try {
                // Show loading state
                const deleteBtn = document.querySelector(`[data-pdf-id="${fileId}"]`);
                if (deleteBtn) {
                    deleteBtn.disabled = true;
                    deleteBtn.innerHTML = '<i data-lucide="loader-2" class="h-4 w-4 animate-spin"></i>';
                    lucide.createIcons();
                }
                
                const response = await makeAuthenticatedRequest(`/api/user/pdfs/${fileId}`, {
                    method: 'DELETE'
                });
                
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error || 'Failed to delete PDF');
                }
                
                const result = await response.json();
                console.log('Delete response:', result);
                
                // If this is the currently open file, reset to upload view
                if (currentFileId === fileId) {
                    resetToUpload();
                }
                
                // Force UI refresh with a slight delay to ensure database changes are reflected
                setTimeout(async () => {
                    await loadUserPDFs();
                    console.log('PDF list reloaded after deletion');
                }, 100);
                
                // Show success message
                showSuccessMessage(`Successfully deleted "${filename}"`);
                
            } catch (error) {
                console.error('Error deleting PDF:', error);
                showError('Failed to delete PDF: ' + error.message);
                
                // Reset button state on error
                const deleteBtn = document.querySelector(`[data-pdf-id="${fileId}"]`);
                if (deleteBtn) {
                    deleteBtn.disabled = false;
                    deleteBtn.innerHTML = '<i data-lucide="trash-2" class="h-4 w-4"></i>';
                    lucide.createIcons();
                }
            }
        }
        
        function showSuccessMessage(message) {
            // Create a temporary success notification
            const successDiv = document.createElement('div');
            successDiv.className = 'fixed top-4 right-4 bg-green-600 text-white px-4 py-2 rounded-lg shadow-lg z-50 transform transition-all duration-300';
            successDiv.textContent = message;
            document.body.appendChild(successDiv);
            
            // Animate in
            setTimeout(() => successDiv.classList.add('opacity-100'), 10);
            
            // Remove after 3 seconds
            setTimeout(() => {
                successDiv.classList.add('opacity-0', 'translate-x-full');
                setTimeout(() => document.body.removeChild(successDiv), 300);
            }, 3000);
        }
        

        function updateProgressWithRateLimit(wordIndex) {
            // Rate-limited progress update - only save every 5 seconds to avoid spam
            if (!this.lastProgressUpdate || Date.now() - this.lastProgressUpdate > 5000) {
                this.lastProgressUpdate = Date.now();
                saveReadingProgress();
            }
        }
        
        function setupUnloadProgressSaving() {
            function saveProgressOnUnload(event) {
                if (!currentFileId) return;
                
                console.log('Page unload detected, saving progress...');
                
                let currentWordIndex = 0;
                let currentPage = 1;
                
                // Get current position from chunk or viewing page
                if (currentChunk) {
                    currentWordIndex = currentChunk.startIndex;
                    const wordInfo = wordMap[currentWordIndex];
                    if (wordInfo) {
                        currentPage = wordInfo.page;
                    }
                } else {
                    currentPage = currentViewingPage;
                }
                
                const progressData = {
                    pdf_id: currentFileId,
                    current_page: currentPage,
                    current_word_index: currentWordIndex,
                    total_words: wordMap.length
                };
                
                // Try navigator.sendBeacon first (most reliable for unload)
                if (navigator.sendBeacon) {
                    const token = localStorage.getItem('auth_token');
                    // Create a FormData with auth token and progress data for sendBeacon
                    const formData = new FormData();
                    formData.append('auth_token', token);
                    formData.append('progress_data', JSON.stringify(progressData));
                    
                    const success = navigator.sendBeacon('/api/reading-progress-beacon', formData);
                    console.log(`Beacon progress save ${success ? 'succeeded' : 'failed'}`);
                    
                    if (success) return;
                }
                
                // Fallback to synchronous save
                try {
                    const xhr = new XMLHttpRequest();
                    xhr.open('POST', '/api/reading-progress', false); // Synchronous
                    xhr.setRequestHeader('Content-Type', 'application/json');
                    const token = localStorage.getItem('auth_token');
                    if (token) {
                        xhr.setRequestHeader('Authorization', `Bearer ${token}`);
                    }
                    xhr.send(JSON.stringify(progressData));
                    console.log('Synchronous progress save completed');
                } catch (error) {
                    console.error('Failed to save progress on unload:', error);
                }
            }
            
            // Multiple event listeners for better coverage
            window.addEventListener('beforeunload', saveProgressOnUnload);
            window.addEventListener('pagehide', saveProgressOnUnload);
            
            // Save when page becomes hidden (user switches tabs, minimizes, etc.)
            document.addEventListener('visibilitychange', () => {
                if (document.visibilityState === 'hidden') {
                    saveProgressOnUnload();
                }
            });
            
            // Save when user navigates away
            window.addEventListener('unload', saveProgressOnUnload);
        }
        
        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }
        
        function escapeHtml(text) {
            const map = {
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                "'": '&#039;'
            };
            return text.replace(/[&<>"']/g, function(m) { return map[m]; });
        }
        
        function truncateFilename(filename, maxLength) {
            if (filename.length <= maxLength) return filename;
            
            // Get file extension
            const lastDotIndex = filename.lastIndexOf('.');
            const extension = lastDotIndex > 0 ? filename.substring(lastDotIndex) : '';
            const nameWithoutExt = lastDotIndex > 0 ? filename.substring(0, lastDotIndex) : filename;
            
            // Calculate available space for name
            const availableLength = maxLength - extension.length - 3; // 3 for "..."
            
            if (availableLength <= 0) {
                return '...' + extension;
            }
            
            return nameWithoutExt.substring(0, availableLength) + '...' + extension;
        }
        
        async function processPDFFile(file) {
            const formData = new FormData();
            formData.append('file', file);
            formData.append('skip_patterns', skipPatterns.toString());
            
            showUploadLoading(true, 'Processing PDF...');
            
            try {
                const response = await makeAuthenticatedRequest('/api/upload', {
                    method: 'POST',
                    body: formData
                });
                
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error || 'Upload failed');
                }
                
                const data = await response.json();
                wordMap = data.words || [];
                
                // Show feedback about pattern filtering if applied
                if (data.skip_patterns_enabled && data.patterns_filtered > 0) {
                    showSuccessMessage(`Filtered ${data.patterns_filtered} repeated words (headers/footers/page numbers) from ${data.original_word_count} total words`);
                }
                
                showUploadLoading(false);
                await displayPDF(file);
                
                // Set the current file ID for progress tracking
                currentFileId = data.file_id;
                
                // Refresh the PDF list to show the new upload
                await loadUserPDFs();
                
            } catch (error) {
                showUploadLoading(false);
                throw error;
            }
        }
        
        async function displayPDF(file) {
            try {
                showLoading('Loading PDF viewer...');
                
                const arrayBuffer = await file.arrayBuffer();
                pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
                const loadingTask = pdfjsLib.getDocument({ data: arrayBuffer });
                pdfDoc = await loadingTask.promise;
                pdfTotalPages = pdfDoc.numPages;
                
                // Initialize current viewing page
                currentViewingPage = 1;
                
                $('upload-container').classList.add('hidden');
                $('pdf-display').classList.remove('hidden');
                
                await fitToWidth();
                await renderInitialView();
                
                setupScrollListener();
                updatePageIndicator();
                
                hideLoading();
            } catch (error) {
                hideLoading();
                throw new Error('Failed to display PDF: ' + error.message);
            }
        }

        async function changeZoom(amount) {
            if (!pdfDoc) return;
            pdfScale += amount;
            pdfScale = Math.max(0.5, Math.min(3, pdfScale)); // Clamp scale
            updateZoomLevel();
            await rerenderVisiblePages();
        }

        function updateZoomLevel() {
            $('pdf-zoom-level').textContent = `${Math.round(pdfScale * 100)}%`;
        }

        async function rerenderVisiblePages() {
            if (!pdfDoc || isViewChanging) return;
            isViewChanging = true;
            try {
                const viewer = $('pdf-viewer');
                const pageElements = Array.from(viewer.querySelectorAll('[data-page-num]'));
                const pagesToRender = pageElements.map(el => parseInt(el.dataset.pageNum));
                
                showLoading(`Applying zoom...`);
                
                viewer.innerHTML = '';
                
                const fragment = document.createDocumentFragment();
                for (const pageNum of pagesToRender) {
                    await renderSinglePage(pageNum, fragment);
                }
                
                viewer.appendChild(fragment);

                hideLoading();
                if (isPlaying || isPaused) updateHighlighting();
            } finally {
                isViewChanging = false;
            }
        }

        function startProgressTracking() {
            // Save progress every 30 seconds during playback
            if (progressSaveInterval) clearInterval(progressSaveInterval);
            progressSaveInterval = setInterval(() => {
                if (isPlaying && currentChunk) {
                    saveReadingProgress();
                }
            }, 30000);
            
            // Update progress display more frequently
            if (progressUpdateInterval) clearInterval(progressUpdateInterval);
            progressUpdateInterval = setInterval(() => {
                if (isPlaying && currentChunk) {
                    updateReadingProgressDisplay();
                }
            }, 1000);
            
            // Initial progress display update
            if (currentChunk) {
                updateReadingProgressDisplay();
            }
        }
        
        function stopProgressTracking() {
            if (progressSaveInterval) {
                clearInterval(progressSaveInterval);
                progressSaveInterval = null;
            }
            if (progressUpdateInterval) {
                clearInterval(progressUpdateInterval);
                progressUpdateInterval = null;
            }
        }
        
        function scrollToWordByIndex(wordIndex) {
            const span = document.querySelector(`.text-span[data-word-index="${wordIndex}"]`);
            if (span) {
                span.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        }

        // --- BACKGROUND MUSIC FUNCTIONS --- //

        async function loadBackgroundMusic() {
            try {
                console.log('Loading background music...');
                const response = await makeAuthenticatedRequest('/api/user/background-music');
                if (response.ok) {
                    const data = await response.json();
                    backgroundMusicFiles = data.music_files || [];
                    console.log('Background music files loaded:', backgroundMusicFiles.length, 'files');
                    updateBackgroundMusicUI();
                } else {
                    console.error('Failed to load background music, status:', response.status);
                    const errorText = await response.text();
                    console.error('Error response:', errorText);
                }
            } catch (error) {
                console.error('Error loading background music:', error);
            }
        }

        function updateBackgroundMusicUI() {
            console.log('Updating background music UI with', backgroundMusicFiles.length, 'files');
            const musicListLoading = $('music-list-loading');
            const musicListContainer = $('music-list-container');
            const musicListEmpty = $('music-list-empty');
            const musicList = $('music-list');
            const musicSelect = $('background-music-select');

            // Hide loading
            if (musicListLoading) musicListLoading.classList.add('hidden');

            if (backgroundMusicFiles.length === 0) {
                console.log('No background music files found, showing empty state');
                if (musicListContainer) musicListContainer.classList.add('hidden');
                if (musicListEmpty) musicListEmpty.classList.remove('hidden');
                if (musicSelect) musicSelect.innerHTML = '<option value="">No music available</option>';
                return;
            }

            // Show music list
            musicListContainer.classList.remove('hidden');
            musicListEmpty.classList.add('hidden');

            // Update music list
            musicList.innerHTML = backgroundMusicFiles.map(music => `
                <div class="flex items-center justify-between p-3 bg-slate-800/40 rounded-xl border border-slate-700/30 hover:bg-slate-700/50 hover:border-purple-500/30 transition-all duration-200">
                    <div class="flex items-center gap-3">
                        <div class="w-8 h-8 bg-purple-500/20 rounded-lg flex items-center justify-center flex-shrink-0">
                            <i data-lucide="music" class="h-4 w-4 text-purple-400"></i>
                        </div>
                        <div>
                            <div class="text-sm font-medium text-slate-200">${escapeHtml(truncateFilename(music.filename, 30))}</div>
                            <div class="text-xs text-slate-400">${formatFileSize(music.file_size)} â€¢ ${music.file_type.toUpperCase()}</div>
                        </div>
                    </div>
                    <button onclick="deleteBackgroundMusic('${music.file_id}')" class="p-2 text-slate-400 hover:text-red-400 rounded-lg hover:bg-red-500/10 transition-all duration-200">
                        <i data-lucide="trash-2" class="h-4 w-4"></i>
                    </button>
                </div>
            `).join('');

            // Update music select dropdown (both desktop and mobile)
            const mobileSelect = $('mobile-background-music-select');
            const selectOptions = '<option value="">Select Music</option>' + 
                backgroundMusicFiles.map(music => 
                    `<option value="${music.file_id}">${escapeHtml(truncateFilename(music.filename, 25))}</option>`
                ).join('');
            
            console.log('Updating select dropdowns with options:', selectOptions);
            if (musicSelect) {
                musicSelect.innerHTML = selectOptions;
                console.log('Desktop select updated');
            }
            if (mobileSelect) {
                mobileSelect.innerHTML = selectOptions;
                console.log('Mobile select updated');
            } else {
                console.warn('Mobile select element not found!');
            }

            // Re-create icons for new elements
            lucide.createIcons();
        }

        async function handleMusicUpload(file) {
            const allowedTypes = ['audio/mpeg', 'audio/wav', 'audio/mp4', 'audio/aac', 'audio/ogg', 'audio/flac'];
            if (!allowedTypes.includes(file.type)) {
                showError('Please upload an audio file (MP3, WAV, M4A, AAC, OGG, FLAC)');
                return;
            }

            if (file.size > 500 * 1024 * 1024) { // 500MB limit
                showError('File size too large. Maximum 500MB allowed.');
                return;
            }

            const formData = new FormData();
            formData.append('file', file);

            try {
                showLoading('Uploading background music...');
                const response = await makeAuthenticatedRequest('/api/upload-background-music', {
                    method: 'POST',
                    body: formData
                });

                if (response.ok) {
                    const data = await response.json();
                    showSuccessMessage(`Background music "${file.name}" uploaded successfully!`);
                    await loadBackgroundMusic(); // Refresh the list
                } else {
                    const errorData = await response.json();
                    showError(errorData.error || 'Failed to upload background music');
                }
            } catch (error) {
                showError('Error uploading background music: ' + error.message);
            } finally {
                hideLoading();
                // Reset the file input
                $('music-input').value = '';
            }
        }

        async function deleteBackgroundMusic(fileId) {
            if (!confirm('Are you sure you want to delete this background music?')) {
                return;
            }

            try {
                const response = await makeAuthenticatedRequest(`/api/user/background-music/${fileId}`, {
                    method: 'DELETE'
                });

                if (response.ok) {
                    showSuccessMessage('Background music deleted successfully!');
                    await loadBackgroundMusic(); // Refresh the list
                    
                    // If this was the currently selected music, reset selection
                    if (currentBackgroundMusic === fileId) {
                        currentBackgroundMusic = null;
                        $('background-music-select').value = '';
                        $('mobile-background-music-select').value = '';
                        stopBackgroundMusic();
                    }
                } else {
                    const errorData = await response.json();
                    showError(errorData.error || 'Failed to delete background music');
                }
            } catch (error) {
                showError('Error deleting background music: ' + error.message);
            }
        }

        function toggleBackgroundMusic(enabled) {
            console.log('Toggling background music:', enabled);
            backgroundMusicEnabled = enabled;
            const controls = $('background-music-controls');
            const mobileControls = $('mobile-background-music-controls');
            const mobileIndicator = $('mobile-music-indicator');
            
            console.log('Background music controls found:', {
                desktop: !!controls,
                mobile: !!mobileControls,
                indicator: !!mobileIndicator
            });
            
            // Sync both desktop and mobile toggles
            const desktopToggle = $('background-music-toggle');
            const mobileToggle = $('mobile-background-music-toggle');
            if (desktopToggle) desktopToggle.checked = enabled;
            if (mobileToggle) mobileToggle.checked = enabled;
            
            if (enabled) {
                console.log('Enabling background music controls');
                if (controls) controls.classList.remove('hidden');
                if (mobileControls) {
                    mobileControls.classList.remove('hidden');
                    console.log('Mobile background music controls shown');
                }
                if (mobileIndicator) mobileIndicator.classList.remove('hidden');
                
                // Setup mobile volume slider when controls become visible
                setTimeout(setupMobileVolumeSlider, 10);
                
                // Ensure background music files are loaded and UI is updated
                if (backgroundMusicFiles.length === 0) {
                    console.log('No background music files loaded, reloading...');
                    loadBackgroundMusic();
                }
                
                if (currentBackgroundMusic && isPlaying) {
                    playBackgroundMusic();
                }
            } else {
                console.log('Disabling background music controls');
                if (controls) controls.classList.add('hidden');
                if (mobileControls) mobileControls.classList.add('hidden');
                if (mobileIndicator) mobileIndicator.classList.add('hidden');
                stopBackgroundMusic();
            }
            
            // Save preferences
            if (currentFileId) {
                saveBookPreferences();
            }
        }

        async function preloadBackgroundMusic(fileId) {
            if (!fileId || bufferedMusicId === fileId) return; // Already buffered
            
            try {
                console.log(`Preloading background music: ${fileId}`);
                
                // Clean up previous buffer
                if (bufferedBackgroundMusic) {
                    URL.revokeObjectURL(bufferedBackgroundMusic);
                    bufferedBackgroundMusic = null;
                    bufferedMusicId = null;
                }
                
                // Fetch and buffer the new audio
                const response = await makeAuthenticatedRequest(`/api/user/background-music/${fileId}`);
                if (!response.ok) {
                    throw new Error(`Failed to fetch background music: ${response.status}`);
                }
                
                const audioBlob = await response.blob();
                bufferedBackgroundMusic = URL.createObjectURL(audioBlob);
                bufferedMusicId = fileId;
                
                console.log(`Background music buffered successfully: ${fileId}`);
                
            } catch (error) {
                console.error('Error preloading background music:', error);
                // Clear failed buffer
                bufferedBackgroundMusic = null;
                bufferedMusicId = null;
            }
        }

        async function selectBackgroundMusic(fileId) {
            if (!fileId) {
                currentBackgroundMusic = null;
                stopBackgroundMusic();
                // Clean up buffer
                if (bufferedBackgroundMusic) {
                    URL.revokeObjectURL(bufferedBackgroundMusic);
                    bufferedBackgroundMusic = null;
                    bufferedMusicId = null;
                }
                // Sync both dropdowns
                $('background-music-select').value = '';
                $('mobile-background-music-select').value = '';
                
                // Save preferences
                if (currentFileId) {
                    await saveBookPreferences();
                }
                return;
            }

            // Stop current music and clean up if playing different music
            if (currentBackgroundMusic !== fileId) {
                stopBackgroundMusic();
            }

            currentBackgroundMusic = fileId;
            
            // Sync both dropdowns
            $('background-music-select').value = fileId;
            $('mobile-background-music-select').value = fileId;
            
            // Preload the selected music for instant playback
            await preloadBackgroundMusic(fileId);
            
            // If TTS is currently playing and background music is enabled, start playing
            if (backgroundMusicEnabled && isPlaying) {
                await playBackgroundMusic();
            }
            
            // Save preferences
            if (currentFileId) {
                await saveBookPreferences();
            }
        }

        async function playBackgroundMusic() {
            console.log('playBackgroundMusic called:', {
                currentBackgroundMusic,
                backgroundMusicEnabled,
                isPlaying
            });
            
            if (!currentBackgroundMusic || !backgroundMusicEnabled) {
                console.log('Background music not enabled or no music selected');
                return;
            }

            try {
                const backgroundAudio = $('background-music-element');
                if (!backgroundAudio) {
                    throw new Error('Background audio element not found');
                }
                
                console.log('Background audio element found:', backgroundAudio);
                let audioUrl;
                
                // Initialize Web Audio API for mobile Safari
                if (isMobileSafari) {
                    console.log('Mobile Safari detected, initializing Web Audio API');
                    const initialized = await initMobileSafariAudioContext();
                    console.log('Web Audio API initialized:', initialized);
                }
                
                // Use buffered audio if available, otherwise fetch it
                if (bufferedBackgroundMusic && bufferedMusicId === currentBackgroundMusic) {
                    console.log('Using buffered background music for instant playback');
                    audioUrl = bufferedBackgroundMusic;
                } else {
                    console.log('Buffered music not available, fetching from server for ID:', currentBackgroundMusic);
                    // Fetch the audio file with authentication and create a blob URL
                    const response = await makeAuthenticatedRequest(`/api/user/background-music/${currentBackgroundMusic}`);
                    console.log('Background music fetch response:', response.status, response.ok);
                    
                    if (!response.ok) {
                        throw new Error(`Failed to fetch background music: ${response.status}`);
                    }
                    
                    const audioBlob = await response.blob();
                    console.log('Audio blob created, size:', audioBlob.size, 'type:', audioBlob.type);
                    audioUrl = URL.createObjectURL(audioBlob);
                    console.log('Blob URL created:', audioUrl);
                }
                
                // Clean up any previous blob URL (but not if it's our buffer)
                if (backgroundAudio.src && backgroundAudio.src.startsWith('blob:') && backgroundAudio.src !== bufferedBackgroundMusic) {
                    console.log('Cleaning up previous blob URL:', backgroundAudio.src);
                    URL.revokeObjectURL(backgroundAudio.src);
                }
                
                // Set the source to the blob URL
                console.log('Setting audio source to:', audioUrl);
                backgroundAudio.src = audioUrl;
                backgroundAudio.loop = true;
                
                // Wait for audio to be ready
                await new Promise((resolve, reject) => {
                    const timeout = setTimeout(() => reject(new Error('Audio load timeout')), 10000);
                    
                    backgroundAudio.addEventListener('canplaythrough', () => {
                        clearTimeout(timeout);
                        console.log('Audio ready to play');
                        resolve();
                    }, { once: true });
                    
                    backgroundAudio.addEventListener('error', (e) => {
                        clearTimeout(timeout);
                        console.error('Audio load error:', e);
                        reject(new Error('Audio load failed'));
                    }, { once: true });
                    
                    // Trigger loading
                    backgroundAudio.load();
                });
                
                // Handle volume control based on platform
                if (isMobileSafari && backgroundAudioContext && backgroundGainNode) {
                    // Mobile Safari: Use Web Audio API for reliable volume control
                    console.log('Mobile Safari: Setting up Web Audio API volume control');
                    
                    // Set HTML5 audio to full volume and use gain node for actual volume control
                    backgroundAudio.volume = 1.0;
                    
                    // Connect to Web Audio API only once per audio element
                    if (!backgroundSourceNode) {
                        try {
                            console.log('Creating Web Audio source node');
                            backgroundSourceNode = backgroundAudioContext.createMediaElementSource(backgroundAudio);
                            backgroundSourceNode.connect(backgroundGainNode);
                            console.log('Web Audio source connected');
                        } catch (error) {
                            if (error.name === 'InvalidStateError' && error.message.includes('already associated')) {
                                console.log('Audio element already connected to Web Audio API, skipping connection');
                                // The audio element is already connected, which is fine
                            } else {
                                console.error('Error creating Web Audio source:', error);
                                // Fall back to standard volume control
                                backgroundAudio.volume = backgroundMusicVolume;
                                return;
                            }
                        }
                    }
                    
                    // Set volume through gain node
                    if (backgroundGainNode) {
                        backgroundGainNode.gain.value = backgroundMusicVolume;
                        console.log(`Mobile Safari: Web Audio gain set to ${backgroundMusicVolume}`);
                    }
                } else {
                    // Standard volume control for other browsers
                    backgroundAudio.volume = backgroundMusicVolume;
                    console.log(`Standard volume control set to ${backgroundMusicVolume}`);
                }
                
                // Resume audio context if suspended (required for mobile Safari)
                if (isMobileSafari && backgroundAudioContext && backgroundAudioContext.state === 'suspended') {
                    console.log('Resuming suspended audio context');
                    await backgroundAudioContext.resume();
                }
                
                // Play background music
                console.log('Attempting to play background music...');
                await backgroundAudio.play();
                console.log(`Background music started successfully`);
                
                // Request wake lock to prevent screen from turning off (helps with mobile Safari)
                if (isMobileSafari && backgroundMusicEnabled) {
                    await requestWakeLock();
                }
                
                // Show mobile status indicator
                const statusIndicator = $('mobile-bg-music-status');
                if (statusIndicator) {
                    statusIndicator.classList.remove('hidden');
                    console.log('Mobile status indicator shown');
                }
                
            } catch (error) {
                console.error('Error playing background music:', error);
                console.error('Error stack:', error.stack);
                showError('Failed to play background music: ' + error.message);
            }
        }

        function stopBackgroundMusic() {
            const backgroundAudio = $('background-music-element');
            backgroundAudio.pause();
            backgroundAudio.currentTime = 0;
            
            // Release wake lock when background music stops
            releaseWakeLock();
            
            // Note: We DON'T disconnect the Web Audio API source node here
            // because once disconnected, we can't reconnect the same audio element
            // The source node will be reused for subsequent playback
            
            // Clean up blob URL to free memory (but keep the buffer)
            if (backgroundAudio.src && backgroundAudio.src.startsWith('blob:') && backgroundAudio.src !== bufferedBackgroundMusic) {
                URL.revokeObjectURL(backgroundAudio.src);
            }
            backgroundAudio.src = '';
            
            // Hide mobile status indicator
            $('mobile-bg-music-status').classList.add('hidden');
        }

        function pauseBackgroundMusic() {
            const backgroundAudio = $('background-music-element');
            backgroundAudio.pause();
            
            // Release wake lock when paused (allow screen to turn off)
            releaseWakeLock();
            
            // Hide mobile status indicator when paused
            $('mobile-bg-music-status').classList.add('hidden');
        }

        function resumeBackgroundMusic() {
            if (!backgroundMusicEnabled || !currentBackgroundMusic) return;
            
            const backgroundAudio = $('background-music-element');
            backgroundAudio.play().then(async () => {
                // Request wake lock again when resuming (helps with mobile Safari)
                if (isMobileSafari && backgroundMusicEnabled) {
                    await requestWakeLock();
                }
                
                // Show mobile status indicator when resumed
                $('mobile-bg-music-status').classList.remove('hidden');
            }).catch(error => {
                console.error('Error resuming background music:', error);
            });
        }

        // Enhanced background music state management for mobile Safari
        function isBackgroundMusicPlaying() {
            const backgroundAudio = $('background-music-element');
            return backgroundAudio && !backgroundAudio.paused && backgroundAudio.src;
        }

        // Initialize Web Audio API for mobile Safari background music volume control
        async function initMobileSafariAudioContext() {
            if (!isMobileSafari || backgroundAudioContext) return;
            
            try {
                backgroundAudioContext = new (window.AudioContext || window.webkitAudioContext)();
                backgroundGainNode = backgroundAudioContext.createGain();
                backgroundGainNode.connect(backgroundAudioContext.destination);
                backgroundGainNode.gain.value = backgroundMusicVolume;
                
                console.log('Mobile Safari Web Audio context initialized for background music volume control');
                
                // Resume context if suspended (required for mobile Safari)
                if (backgroundAudioContext.state === 'suspended') {
                    await backgroundAudioContext.resume();
                }
                
                return true;
            } catch (error) {
                console.error('Failed to initialize mobile Safari audio context:', error);
                return false;
            }
        }

        // Wake Lock functions to prevent screen from locking
        async function requestWakeLock() {
            if (!isWakeLockSupported || wakeLock) return;
            
            try {
                wakeLock = await navigator.wakeLock.request('screen');
                console.log('Wake lock acquired to prevent screen from turning off');
                
                wakeLock.addEventListener('release', () => {
                    console.log('Wake lock released');
                    wakeLock = null;
                });
            } catch (error) {
                console.error('Failed to acquire wake lock:', error);
            }
        }

        async function releaseWakeLock() {
            if (wakeLock) {
                try {
                    await wakeLock.release();
                    wakeLock = null;
                    console.log('Wake lock manually released');
                } catch (error) {
                    console.error('Failed to release wake lock:', error);
                }
            }
        }



        // Volume save timeout for debouncing
        let volumeSaveTimeout = null;
        
        function setBackgroundMusicVolume(sliderValue) {
            // Convert slider value (0-50) to percentage (0-100) and then to decimal (0-1)
            const percentage = (sliderValue / 50) * 100; // 0-50 -> 0-100
            backgroundMusicVolume = percentage / 100; // 0-100 -> 0-1
            
            console.log(`setBackgroundMusicVolume called with: ${sliderValue}`);
            console.log(`Volume slider: ${sliderValue}, percentage: ${percentage}%, decimal: ${backgroundMusicVolume}`);
            
            // Sync both desktop and mobile volume controls 
            const desktopSlider = $('background-music-volume');
            const mobileSlider = $('mobile-background-music-volume');
            const desktopText = $('background-volume-text');
            const mobileText = $('mobile-background-volume-text');
            
            console.log('Updating volume controls - Desktop slider:', desktopSlider, 'Mobile slider:', mobileSlider);
            
            if (desktopSlider) desktopSlider.value = sliderValue;
            if (mobileSlider) mobileSlider.value = sliderValue;
            if (desktopText) desktopText.textContent = `${Math.round(percentage)}%`;
            if (mobileText) mobileText.textContent = `${Math.round(percentage)}%`;
            
            // Apply volume immediately
            updateAudioVolumes();
            
            // Debounced save to database
            if (currentFileId) {
                clearTimeout(volumeSaveTimeout);
                volumeSaveTimeout = setTimeout(() => {
                    saveBookPreferences();
                }, 500); // Save after 500ms of no changes
            }
        }

        function updateAudioVolumes() {
            // Apply background music volume
            const backgroundAudio = $('background-music-element');
            if (backgroundAudio) {
                if (isMobileSafari && backgroundAudioContext && backgroundGainNode) {
                    // Mobile Safari: Use Web Audio API gain node for volume control
                    backgroundGainNode.gain.value = backgroundMusicVolume;
                    console.log(`Mobile Safari: Updated Web Audio gain to ${backgroundMusicVolume}`);
                    
                    // Ensure HTML5 audio stays at full volume
                    backgroundAudio.volume = 1.0;
                } else {
                    // Standard volume application for other browsers
                    backgroundAudio.volume = backgroundMusicVolume;
                    console.log(`Applied volume ${backgroundMusicVolume} to background audio element`);
                }
            } else {
                console.warn('Background audio element not found');
            }
        }

        // Modify existing playback functions to integrate background music

        // Override the original togglePlayPause to handle background music
        const originalTogglePlayPause = togglePlayPause;
        togglePlayPause = async function() {
            const wasPlaying = isPlaying;
            await originalTogglePlayPause();
            
            // Handle background music based on new playback state
            if (isPlaying && !wasPlaying) {
                // Started playing
                if (backgroundMusicEnabled && currentBackgroundMusic) {
                    await playBackgroundMusic();
                }
            } else if (!isPlaying && wasPlaying) {
                // Paused
                pauseBackgroundMusic();
            }
        };

        // Override the original stopPlayback to handle background music
        const originalStopPlayback = stopPlayback;
        stopPlayback = async function() {
            await originalStopPlayback();
            stopBackgroundMusic();
        };

        function showSuccessMessage(message) {
            const errorSection = $('error-section');
            const errorMessage = $('error-message');
            
            errorSection.className = 'fixed bottom-24 sm:bottom-4 left-1/2 -translate-x-1/2 w-auto bg-green-600/90 text-white p-4 rounded-lg shadow-lg z-[10000]';
            errorMessage.textContent = message;
            errorSection.classList.remove('hidden');
            
            setTimeout(() => {
                errorSection.classList.add('hidden');
                errorSection.className = 'hidden fixed bottom-24 sm:bottom-4 left-1/2 -translate-x-1/2 w-auto bg-red-600/90 text-white p-4 rounded-lg shadow-lg z-[10000]';
            }, 3000);
        }

        // --- DEFAULT PREFERENCES FUNCTIONS --- //
        let isTestingVoice = false;
        
        async function testVoiceAndSpeed() {
            const testBtn = $('test-voice-btn');
            const testBtnText = $('test-voice-btn-text');
            const testAudio = $('test-audio-player');
            
            // If currently testing, stop the audio
            if (isTestingVoice) {
                stopTestAudio();
                return;
            }
            
            // Get selected voice and speed
            const selectedVoice = $('default-voice-select').value;
            const selectedSpeed = parseFloat($('default-speed-select').value);
            
            // Sample text for testing
            const sampleText = "Hello! This is a preview of how your selected voice and speed will sound when reading your PDFs. You can adjust these settings anytime in your preferences.";
            
            try {
                // Update button state
                isTestingVoice = true;
                testBtn.disabled = true;
                testBtnText.textContent = 'Generating...';
                testBtn.className = testBtn.className.replace('bg-green-600 hover:bg-green-700', 'bg-gray-600 hover:bg-gray-700');
                
                // Generate audio with selected voice
                const response = await makeAuthenticatedRequest('/api/generate-audio', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ text: sampleText, model: selectedVoice })
                });

                if (!response.ok) {
                    throw new Error((await response.json()).error || 'Failed to generate test audio');
                }
                
                const data = await response.json();
                const blob = new Blob([Uint8Array.from(atob(data.audio_data), c => c.charCodeAt(0))], { type: 'audio/wav' });
                const audioUrl = URL.createObjectURL(blob);
                
                // Set up audio player
                testAudio.src = audioUrl;
                testAudio.playbackRate = selectedSpeed;
                
                // Update button to show playing state (clickable to stop)
                testBtn.disabled = false;
                testBtnText.textContent = 'Stop Test';
                testBtn.className = testBtn.className.replace('bg-gray-600 hover:bg-gray-700', 'bg-red-600 hover:bg-red-700');
                
                // Play the audio
                await testAudio.play();
                
                // Reset button when audio ends naturally
                testAudio.onended = () => {
                    stopTestAudio();
                };
                
                // Store the blob URL for cleanup
                testAudio.blobUrl = audioUrl;
                
            } catch (error) {
                console.error('Error testing voice:', error);
                showError('Failed to test voice: ' + error.message);
                stopTestAudio();
            }
        }
        
        function stopTestAudio() {
            const testBtn = $('test-voice-btn');
            const testBtnText = $('test-voice-btn-text');
            const testAudio = $('test-audio-player');
            
            // Stop and reset audio
            testAudio.pause();
            testAudio.currentTime = 0;
            
            // Clean up blob URL if it exists
            if (testAudio.blobUrl) {
                URL.revokeObjectURL(testAudio.blobUrl);
                testAudio.blobUrl = null;
            }
            
            // Reset audio source
            testAudio.src = '';
            
            // Reset button state
            isTestingVoice = false;
            testBtn.disabled = false;
            testBtnText.textContent = 'Test Voice & Speed';
            testBtn.className = testBtn.className.replace('bg-red-600 hover:bg-red-700', 'bg-green-600 hover:bg-green-700').replace('bg-gray-600 hover:bg-gray-700', 'bg-green-600 hover:bg-green-700');
        }

        async function saveDefaultPreferences() {
            const saveBtn = $('save-default-prefs-btn');
            const selectedVoice = $('default-voice-select').value;
            const selectedSpeed = parseFloat($('default-speed-select').value);
            const selectedSkipPatterns = $('default-skip-patterns').checked;
            
            try {
                saveBtn.disabled = true;
                saveBtn.innerHTML = '<i data-lucide="loader-2" class="h-4 w-4 animate-spin"></i> Saving...';
                
                // Update local preferences
                selectedModel = selectedVoice;
                currentPlaybackRate = selectedSpeed;
                skipPatterns = selectedSkipPatterns;
                
                // Save to database
                const response = await makeAuthenticatedRequest('/api/user/preferences', {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        voice_model: selectedVoice,
                        voice_speed: selectedSpeed,
                        skip_patterns: selectedSkipPatterns
                    })
                });

                if (!response.ok) {
                    throw new Error('Failed to save preferences');
                }
                
                // Update UI controls to reflect saved preferences
                selectedModel = selectedVoice;
                currentPlaybackRate = selectedSpeed;
                
                // Sync with PDF player controls if they exist
                const desktopVoiceSelect = $('sticky-voice-select');
                const mobileVoiceSelect = $('mobile-voice-select');
                const desktopSpeedSelect = $('sticky-speed-select');
                const mobileSpeedSelect = $('mobile-speed-select');
                
                if (desktopVoiceSelect) desktopVoiceSelect.value = selectedVoice;
                if (mobileVoiceSelect) mobileVoiceSelect.value = selectedVoice;
                if (desktopSpeedSelect) desktopSpeedSelect.value = selectedSpeed;
                if (mobileSpeedSelect) mobileSpeedSelect.value = selectedSpeed;
                
                showSuccessMessage('Default preferences saved successfully!');
                
            } catch (error) {
                console.error('Error saving preferences:', error);
                showError('Failed to save preferences: ' + error.message);
            } finally {
                saveBtn.disabled = false;
                saveBtn.innerHTML = '<i data-lucide="save" class="h-4 w-4"></i> Save as Default';
                lucide.createIcons(); // Refresh icons
            }
        }

        function updateDefaultPreferencesUI() {
            // This function can be used to provide real-time feedback 
            // as user changes selections (future enhancement)
        }

        function applyPreferencesToDefaultUI() {
            // Apply loaded user preferences to the default preferences UI
            try {
                const defaultVoiceSelect = $('default-voice-select');
                const defaultSpeedSelect = $('default-speed-select');
                const defaultSkipPatterns = $('default-skip-patterns');
                
                if (defaultVoiceSelect && selectedModel) {
                    defaultVoiceSelect.value = selectedModel;
                }
                if (defaultSpeedSelect && currentPlaybackRate) {
                    defaultSpeedSelect.value = currentPlaybackRate;
                }
                if (defaultSkipPatterns) {
                    defaultSkipPatterns.checked = skipPatterns;
                }
            } catch (error) {
                console.log('Default preferences UI not available (user might be in PDF view)');
            }
        }

        // PDF Loading Indicator
        function showUploadLoading(text) {
            const loadingEl = $('upload-loading-text');
            const loadingTextEl = $('upload-loading-text-inner');
            if (loadingEl && loadingTextEl) {
                // If text is not a valid string, show a default message
                loadingTextEl.textContent = (typeof text === 'string' && text.length > 0) ? text : 'Loading...';
                loadingEl.classList.remove('hidden');
            }
        }

        function hideUploadLoading() {
            const loadingEl = $('upload-loading-text');
            if (loadingEl) {
                loadingEl.classList.add('hidden');
            }
        }
    </script>
</body>
</html> 